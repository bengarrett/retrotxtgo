package logs

import (
	"bytes"
	"errors"
	"fmt"
	"log"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/alecthomas/chroma/quick"
	"github.com/gookit/color"
	gap "github.com/muesli/go-app-paths"
)

// the lowest, largest and recommended network ports to serve HTTP.
const (
	PortMin uint = 0
	PortMax uint = 65535
	PortRec uint = 8080
)

// Err is an interface for error colored messages
type Err struct {
	// Issue is a summary of the problem
	Issue string
	// Arg is the argument, flag or item that triggered the error
	Arg string
	// Msg is the actual error generated
	Msg error
}

func (e Err) String() string {
	if e.Msg == nil {
		return ""
	}
	issue := Ci(fmt.Sprintf("%s %s,", e.Issue, e.Arg))
	msg := Cf(fmt.Sprintf("%v", e.Msg))
	return fmt.Sprintf("%s %s %s", Alert(), issue, msg)
}

// Filename is the default error log filename
const Filename = "errors.log"

// posix permissions for the configuration file and directory.
const perm = 0600
const permDir = 0700

var (
	scope = gap.NewScope(gap.User, "df2")
	// Panic uses the panic function to handle all error logs.
	Panic = false
)

// color aliases
var (
	Alert = func() string {
		return color.Error.Sprint("problem:")
	}
	Cc = func(t string) string {
		return color.Comment.Sprint(t)
	}
	Ce = func(t string) string {
		return color.Warn.Sprint(t)
	}
	Cf = func(t string) string {
		return color.OpFuzzy.Sprint(t)
	}
	Ci = func(t string) string {
		return color.OpItalic.Sprint(t)
	}
	Cinf = func(t string) string {
		return color.Info.Sprint(t)
	}
	Cp = func(t string) string {
		return color.Primary.Sprint(t)
	}
	Cs = func(t string) string {
		return color.Success.Sprint(t)
	}
)

// Check prints an error issue and message then exits the program.
func Check(issue string, err error) (ok bool) {
	if err != nil {
		Exit(check(issue, err))
	}
	return true
}

func check(issue string, err error) (msg string, code int) {
	code = 1
	if err == nil {
		err = errors.New("")
	}
	if issue == "" {
		msg = fmt.Sprintf("%s\n", err)
	} else {
		msg = fmt.Sprintf("%s %s\n", issue, err)
	}
	return msg, code
}

// CheckArg returns instructions for invalid command arguments.
func CheckArg(arg string, args []string) {
	if len(args) == 0 {
		return
	}
	Exit(checkArgument(arg, args))
}

func checkArgument(arg string, args []string) (msg string, code int) {
	code = 10
	msg += fmt.Sprintf("%s invalid argument%s", Alert(),
		color.Bold.Sprintf(" %q", arg))
	if len(args) > 1 {
		msg += fmt.Sprintf(" choices: %s\n%s",
			color.Info.Sprintf("%s", strings.Join(args, ", ")),
			color.Warn.Sprint("please use one of the argument choices shown above"))
	}
	msg += "\n"
	return msg, code
}

// CheckCmd parses any root command errors generated by cobra execute.
func CheckCmd(err error) {
	s := fmt.Sprintf("%s", err)
	w := strings.Split(s, " ")
	switch {
	case unknownFlag(s):
		ChkErr(Err{Issue: "invalid flag", Arg: w[len(w)-1],
			Msg: fmt.Errorf("is not a flag in use for this command")})
	case emptyFlag(s):
		ChkErr(Err{Issue: "invalid flag", Arg: w[len(w)-1],
			Msg: fmt.Errorf("cannot be empty and requires a value")})
	case reqFlag(s):
		ChkErr(Err{Issue: "a required flag missing", Arg: w[2],
			Msg: err}) // TODO: test
	case unknownCmd(s):
		ChkErr(Err{Issue: "invalid command", Arg: w[2],
			Msg: err})
	case s == "subcommand is required":
		return // ignore error
	default:
		ChkErr(Err{"command", "execute", err})
	}
}

func checkSubStr(sub, s string) bool {
	sl := len(s)
	if z := len(sub); sl > z && s[:z] == sub {
		return true
	}
	return false
}

func unknownFlag(s string) bool {
	const a, b = "unknown shorthand flag", "unknown flag"
	if checkSubStr(a, s) {
		return true
	}
	if checkSubStr(b, s) {
		return true
	}
	return false
}

func emptyFlag(s string) bool {
	const a = "flag needs an argument"
	if checkSubStr(a, s) {
		return true
	}
	return false
}

func reqFlag(s string) bool {
	const a = "required flag(s)"
	if checkSubStr(a, s) {
		return true
	}
	return false
}

func unknownCmd(s string) bool {
	const a = "unknown command"
	if checkSubStr(a, s) {
		return true
	}
	return false
}

// CheckNilArg returns instructions for empty command arguments.
func CheckNilArg(arg string, args []string) {
	if len(args) != 0 {
		return
	}
	Exit(checkNilArgument(arg, args))
}

func checkNilArgument(arg string, args []string) (msg string, code int) {
	msg += fmt.Sprintf("%s required argument%s cannot be empty and requires a value\n", Alert(), color.Bold.Sprintf(" %q", arg))
	return msg, code
}

// ChkErr prints an error message and exits the program.
func ChkErr(e Err) {
	if e.Msg != nil {
		Exit(e.check())
	}
}

func (e Err) check() (msg string, code int) {
	code = 1
	msg = e.String()
	return msg, code
}

// ColorHTML prints colored syntax highlighting to HTML elements.
func ColorHTML(elm string) {
	fmt.Println(colorhtml(&elm))
}

func colorhtml(elm *string) string {
	var buf bytes.Buffer
	if err := quick.Highlight(&buf, *elm, "html", "terminal256", "lovelace"); err != nil {
		return fmt.Sprintf("\n%s\n", *elm)
	}
	if len(buf.String()) == 0 {
		return ""
	}
	return fmt.Sprintf("\n%v\n", buf.String())
}

// Exit prints the message and causes the program to exit.
func Exit(msg string, code int) {
	i, err := fmt.Println(msg)
	if err != nil {
		log.Fatalf("logs.exit println at %dB: %s", i, err)
	}
	os.Exit(code)
}

// Log the error and exit to the operating system with the error code 1.
func Log(err error) {
	if err != nil {
		// save error to log file
		if err := save(err, ""); err != nil {
			log.Fatalf("%s %s", color.Danger.Sprint("!"), err)
		}
		// print error
		switch Panic {
		case true:
			log.Println(fmt.Sprintf("error type: %T\tmsg: %v", err, err))
			log.Panic(err)
		default:
			log.Fatal(color.Danger.Sprint("ERROR: "), err)
		}
	}
}

// save an error to the log directory, an optional named file is available for unit tests.
func save(err error, name string) error {
	if err == nil || fmt.Sprintf("%v", err) == "" {
		return errors.New("logs save: err value is nil")
	}
	// use UTC date and times in the log file
	log.SetFlags(log.Ldate | log.Ltime | log.LUTC)
	if name == "" {
		name = Filepath()
	}
	p := filepath.Dir(name)
	if _, e := os.Stat(p); os.IsNotExist(e) {
		if e := os.MkdirAll(p, permDir); e != nil {
			return e
		}
	}
	file, e := os.OpenFile(name, os.O_APPEND|os.O_CREATE|os.O_WRONLY, perm)
	if e != nil {
		return e
	}
	defer file.Close()
	log.SetOutput(file)
	log.Print(err)
	log.SetOutput(os.Stderr)
	return nil
}

// Filepath is the absolute path and filename of the error log file.
func Filepath() string {
	fp, err := scope.LogPath(Filename)
	if err != nil {
		h, _ := os.UserHomeDir()
		return path.Join(h, Filename)
	}
	return fp
}
