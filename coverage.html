
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>byter: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/bengarrett/retrotxtgo/byter/byter.go (83.7%)</option>
				
				<option value="file1">github.com/bengarrett/retrotxtgo/cmd/cmd.go (40.0%)</option>
				
				<option value="file2">github.com/bengarrett/retrotxtgo/cmd/example.go (85.7%)</option>
				
				<option value="file3">github.com/bengarrett/retrotxtgo/cmd/example/example.go (86.1%)</option>
				
				<option value="file4">github.com/bengarrett/retrotxtgo/cmd/hex.go (55.6%)</option>
				
				<option value="file5">github.com/bengarrett/retrotxtgo/cmd/hexa/hexa.go (97.2%)</option>
				
				<option value="file6">github.com/bengarrett/retrotxtgo/cmd/info.go (100.0%)</option>
				
				<option value="file7">github.com/bengarrett/retrotxtgo/cmd/internal/dump/dump.go (17.9%)</option>
				
				<option value="file8">github.com/bengarrett/retrotxtgo/cmd/internal/flag/flag.go (8.2%)</option>
				
				<option value="file9">github.com/bengarrett/retrotxtgo/cmd/internal/flag/flags.go (12.5%)</option>
				
				<option value="file10">github.com/bengarrett/retrotxtgo/cmd/internal/format/format.go (100.0%)</option>
				
				<option value="file11">github.com/bengarrett/retrotxtgo/cmd/internal/info/info.go (32.0%)</option>
				
				<option value="file12">github.com/bengarrett/retrotxtgo/cmd/internal/view/view.go (19.3%)</option>
				
				<option value="file13">github.com/bengarrett/retrotxtgo/cmd/lang.go (80.0%)</option>
				
				<option value="file14">github.com/bengarrett/retrotxtgo/cmd/list.go (80.0%)</option>
				
				<option value="file15">github.com/bengarrett/retrotxtgo/cmd/list/list.go (91.7%)</option>
				
				<option value="file16">github.com/bengarrett/retrotxtgo/cmd/online/online.go (42.1%)</option>
				
				<option value="file17">github.com/bengarrett/retrotxtgo/cmd/table.go (66.7%)</option>
				
				<option value="file18">github.com/bengarrett/retrotxtgo/cmd/terminal.go (66.7%)</option>
				
				<option value="file19">github.com/bengarrett/retrotxtgo/cmd/update/update.go (34.4%)</option>
				
				<option value="file20">github.com/bengarrett/retrotxtgo/cmd/version/version.go (46.2%)</option>
				
				<option value="file21">github.com/bengarrett/retrotxtgo/cmd/view.go (87.0%)</option>
				
				<option value="file22">github.com/bengarrett/retrotxtgo/convert/convert.go (82.0%)</option>
				
				<option value="file23">github.com/bengarrett/retrotxtgo/convert/encoding.go (71.2%)</option>
				
				<option value="file24">github.com/bengarrett/retrotxtgo/fsys/fsys.go (80.0%)</option>
				
				<option value="file25">github.com/bengarrett/retrotxtgo/fsys/read.go (85.5%)</option>
				
				<option value="file26">github.com/bengarrett/retrotxtgo/fsys/reader.go (70.7%)</option>
				
				<option value="file27">github.com/bengarrett/retrotxtgo/fsys/zip.go (17.5%)</option>
				
				<option value="file28">github.com/bengarrett/retrotxtgo/info/detail.go (79.2%)</option>
				
				<option value="file29">github.com/bengarrett/retrotxtgo/info/info.go (76.0%)</option>
				
				<option value="file30">github.com/bengarrett/retrotxtgo/internal/mock/mock.go (18.1%)</option>
				
				<option value="file31">github.com/bengarrett/retrotxtgo/internal/save/save.go (80.0%)</option>
				
				<option value="file32">github.com/bengarrett/retrotxtgo/internal/tmp/tmp.go (100.0%)</option>
				
				<option value="file33">github.com/bengarrett/retrotxtgo/logs/execute.go (4.3%)</option>
				
				<option value="file34">github.com/bengarrett/retrotxtgo/logs/logs.go (62.2%)</option>
				
				<option value="file35">github.com/bengarrett/retrotxtgo/main.go (0.0%)</option>
				
				<option value="file36">github.com/bengarrett/retrotxtgo/meta/meta.go (96.2%)</option>
				
				<option value="file37">github.com/bengarrett/retrotxtgo/nl/nl.go (75.4%)</option>
				
				<option value="file38">github.com/bengarrett/retrotxtgo/sample/sample.go (80.4%)</option>
				
				<option value="file39">github.com/bengarrett/retrotxtgo/table/lang.go (89.7%)</option>
				
				<option value="file40">github.com/bengarrett/retrotxtgo/table/list.go (95.2%)</option>
				
				<option value="file41">github.com/bengarrett/retrotxtgo/table/table.go (59.5%)</option>
				
				<option value="file42">github.com/bengarrett/retrotxtgo/term/term.go (59.6%)</option>
				
				<option value="file43">github.com/bengarrett/retrotxtgo/xud/xud.go (54.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package byter provides functions that manipulate or return byte arrays.
package byter

import (
        "bytes"
        "encoding/hex"
        "errors"
        "fmt"
        "io"
        "strings"
        "unicode/utf8"

        "golang.org/x/text/encoding/charmap"
        "golang.org/x/text/transform"
)

var (
        ErrCharmap = errors.New("the c charmap cannot be nil")
        ErrUTF8    = errors.New("string cannot encode to utf-8")
)

const (
        SUB       = 26   // SUB is the ASCII control code for substitute.
        DosSUB    = 8594 // DosSub is the Unicode for the right-arrow.
        SymbolSUB = 9242 // SymbolSUB is the Unicode for the substitute character.
)

// BOM is the UTF-8 byte order mark prefix.
func BOM() []byte <span class="cov8" title="1">{
        const ef, bb, bf = 239, 187, 191
        return []byte{ef, bb, bf}
}</span>

// TrimEOF will cut text at the first occurrence of the SUB character.
// The SUB is used by DOS and CP/M as an end-of-file marker.
func TrimEOF(b []byte) []byte <span class="cov8" title="1">{
        // ASCII control code
        cut := bytes.IndexByte(b, SUB)
        if cut &gt; 0 &amp;&amp; len(b) &gt; cut </span><span class="cov8" title="1">{
                return b[:cut]
        }</span>
        // UTF-8 symbol for substitute character
        <span class="cov8" title="1">s := string(b)
        if cut := strings.IndexRune(s, SymbolSUB); cut &gt; 0 </span><span class="cov0" title="0">{
                return []byte(s[:cut])
        }</span>
        // UTF-8 right-arrow which is displayed for the CP-437 substitute character code point 26
        <span class="cov8" title="1">if cut := strings.IndexRune(s, DosSUB); cut &gt; 0 </span><span class="cov0" title="0">{
                return []byte(s[:cut])
        }</span>
        <span class="cov8" title="1">return b</span>
}

// MakeBytes generates a 256 character or 8-bit container ready to hold legacy code point values.
func MakeBytes() []byte <span class="cov8" title="1">{
        const size = 256
        m := make([]byte, size)
        for i := range size </span><span class="cov8" title="1">{
                m[i] = byte(i)
        }</span>
        <span class="cov8" title="1">return m</span>
}

// Mark adds a UTF-8 byte order mark to the text if it doesn't already exist.
func Mark(b []byte) []byte <span class="cov8" title="1">{
        const size = 3
        if len(b) &gt;= size </span><span class="cov8" title="1">{
                if t := b[:3]; bytes.Equal(t, BOM()) </span><span class="cov8" title="1">{
                        return b
                }</span>
        }
        <span class="cov8" title="1">return append(BOM(), b...)</span>
}

// HexDecode decodes a hexadecimal string into bytes.
func HexDecode(s string) ([]byte, error) <span class="cov8" title="1">{
        src := []byte(s)
        dst := make([]byte, hex.DecodedLen(len(src)))
        if _, err := hex.Decode(dst, src); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not decode hexadecimal string: %q: %w", s, err)
        }</span>
        <span class="cov8" title="1">return dst, nil</span>
}

// HexEncode encodes a string into hexadecimal bytes.
func HexEncode(s string) []byte <span class="cov8" title="1">{
        src := []byte(s)
        dst := make([]byte, hex.EncodedLen(len(src)))
        hex.Encode(dst, src)
        return dst
}</span>

// Decode a string using the character map.
func Decode(c *charmap.Charmap, s string) ([]byte, error) <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return nil, ErrCharmap
        }</span>
        <span class="cov8" title="1">decoder := c.NewDecoder()
        reader := transform.NewReader(strings.NewReader(s), decoder)
        b, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dstring io.readall error: %w", err)
        }</span>
        <span class="cov8" title="1">return b, nil</span>
}

// Encode the string using the character map.
func Encode(c *charmap.Charmap, s string) ([]byte, error) <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return nil, ErrCharmap
        }</span>
        <span class="cov8" title="1">b := []byte(s)
        if !utf8.Valid(b) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("estring: %w", ErrUTF8)
        }</span>
        <span class="cov8" title="1">encoder := c.NewEncoder()
        reader := transform.NewReader(strings.NewReader(s), encoder)
        p, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("estring io.readall error: %w", err)
        }</span>
        <span class="cov8" title="1">return p, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package cmd handles the terminal interface, user flags and arguments.
package cmd

import (
        "errors"
        "fmt"
        "os"
        "strings"

        "github.com/bengarrett/retrotxtgo/cmd/example"
        "github.com/bengarrett/retrotxtgo/cmd/internal/flag"
        "github.com/bengarrett/retrotxtgo/cmd/version"
        "github.com/bengarrett/retrotxtgo/logs"
        "github.com/bengarrett/retrotxtgo/meta"
        "github.com/spf13/cobra"
)

var (
        ErrHide  = errors.New("could not hide the flag")
        ErrUsage = errors.New("command usage could not display")
)

// ID are the cobra command group IDs.
const (
        IDcodepage = "idcp"     // codepage group
        IDfile     = "idfile"   // file group
        IDsample   = "idsample" // sample group
)

// Cmd represents the base command when called without any subcommands.
var Cmd = base()

func base() *cobra.Command <span class="cov8" title="1">{
        s := "Use " + meta.Name + " to print legacy text on modern terminals."
        l := "Text files and art created without Unicode often fail to display on modern systems. " +
                "\n" + s
        expl := strings.Builder{}
        example.Cmd.String(&amp;expl)
        return &amp;cobra.Command{
                Use:     meta.Bin,
                Short:   s,
                Long:    l,
                Example: expl.String(),
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        // Do nothing other than print the help.
                        // This func must remain otherwise root
                        // command flags are ignored by Cobra.
                        return flag.Help(cmd)
                }</span>,
        }
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() error <span class="cov0" title="0">{
        // disable the default "completion" command.
        Cmd.CompletionOptions.DisableDefaultCmd = true
        // hide the cobra introduced "help" command.
        // https://github.com/spf13/cobra/issues/587#issuecomment-810159087
        Cmd.SetHelpCommand(&amp;cobra.Command{Hidden: true})
        // the help "command" is hidden, so it needs to be assigned to a
        // group otherwise it will display an empty "Additional Commands:".
        Cmd.SetHelpCommandGroupID(IDcodepage)
        // hide the cobra errors.
        Cmd.SilenceErrors = true // set to false to debug errors
        // build the version flag template.
        Cmd.Version = meta.String()
        s := strings.Builder{}
        if err := version.Template(&amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">Cmd.SetVersionTemplate(s.String())
        if errE := Cmd.Execute(); errE != nil </span><span class="cov0" title="0">{
                const minArgs = 2
                if len(os.Args) &lt; minArgs </span><span class="cov0" title="0">{
                        if errU := Cmd.Usage(); errU != nil </span><span class="cov0" title="0">{
                                logs.FatalS(ErrUsage, errU, "rootCmd")
                        }</span>
                }
                <span class="cov0" title="0">args := ""
                if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                        args = strings.Join(os.Args[1:], " ")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("%w: %s %s", errE, meta.Bin, strings.TrimSpace(args))</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Tester creates and hides a custom tester flag.
// It is its own function so it can also be applied to unit tests as well as init.
func Tester(c *cobra.Command) *cobra.Command <span class="cov8" title="1">{
        c.PersistentFlags().BoolVar(&amp;flag.Cmd.Tester, "tester", false,
                "optional in-memory, tester config file")
        if err := c.PersistentFlags().MarkHidden("tester"); err != nil </span><span class="cov0" title="0">{
                logs.FatalS(ErrHide, err, "tester")
        }</span>
        <span class="cov8" title="1">return c</span>
}

func init() <span class="cov8" title="1">{
        Cmd = Tester(Cmd)
        c := &amp;cobra.Group{ID: IDcodepage, Title: "Codepage:"}
        f := &amp;cobra.Group{ID: IDfile, Title: "File:"}
        s := &amp;cobra.Group{ID: IDsample, Title: "Sample:"}
        Cmd.AddGroup(c, f, s)
        // create a version flag that only works on root.
        Cmd.LocalNonPersistentFlags().BoolP("version", "v", false, "")
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"
        "strings"

        "github.com/bengarrett/retrotxtgo/cmd/example"
        "github.com/bengarrett/retrotxtgo/cmd/list"
        "github.com/bengarrett/retrotxtgo/term"
        "github.com/spf13/cobra"
)

func ListExample() *cobra.Command <span class="cov8" title="1">{
        s := fmt.Sprintf("List the included sample text files available for use with the %s and %s commands",
                term.Example("info"), term.Example("view"))
        l := fmt.Sprintf("List the included sample text art and documents available for use with the %s and %s commands.",
                term.Example("info"), term.Example("view"))
        expl := strings.Builder{}
        example.Examples.String(&amp;expl)
        return &amp;cobra.Command{
                Use:     "example",
                Aliases: []string{"e", "sample", "s"},
                GroupID: IDsample,
                Short:   s,
                Long:    l,
                Example: expl.String(),
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return list.Examples(cmd.OutOrStdout())
                }</span>,
        }
}

func init() <span class="cov8" title="1">{
        Cmd.AddCommand(ListExample())
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package example provides help usage examples for the cmd package.
package example

import (
        "bufio"
        "bytes"
        "fmt"
        "io"
        "log"
        "os"
        "strings"
        "text/template"

        "github.com/bengarrett/retrotxtgo/meta"
        "github.com/bengarrett/retrotxtgo/term"
        "github.com/gookit/color"
)

// Filenames is the placeholder for the filenames in the help usage examples.
const Filenames = "[filenames]"

// Example is the type for the help usage examples.
type Example int

const (
        Cmd      Example = iota // Cmd is the example for the root command.
        Examples                // Examples are the examples for the list examples command.
        Table                   // Table are the examples for the list tables command.
        Info                    // Info is the example for the info command.
        View                    // View is the example for the view command.
        Dump                    // Dump is the example for the dump command.
)

// Example string writes the example usage help.
func (e Example) String(w io.Writer) <span class="cov8" title="1">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">b := &amp;bytes.Buffer{}
        // change example operating system path separator
        t := template.Must(template.New("example").Parse(e.result()))
        err := t.Execute(b, string(os.PathSeparator))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        // color the example text except text following
        // the last hash #, which is treated as a comment
        <span class="cov8" title="1">const cmmt, sentence = "#", 2
        scanner := bufio.NewScanner(b)
        cnt := 0
        rows := len(strings.Split(b.String(), "\n"))
        for scanner.Scan() </span><span class="cov8" title="1">{
                cnt++
                s := strings.Split(scanner.Text(), cmmt)
                l := len(s)
                if l &lt; sentence </span><span class="cov8" title="1">{
                        fmt.Fprint(w, term.Info(scanner.Text()))
                        if cnt &lt; rows </span><span class="cov8" title="1">{
                                fmt.Fprintln(w)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">if len(s) &lt; 1 </span><span class="cov0" title="0">{
                        break</span>
                }
                // do not the last hash as a comment
                <span class="cov8" title="1">ex := strings.Join(s[:l-1], cmmt)
                fmt.Fprint(w, term.Info(ex))
                fmt.Fprintf(w, "%s%s", color.Secondary.Sprint(cmmt), s[l-1])
                if cnt &lt; rows </span><span class="cov8" title="1">{
                        fmt.Fprintln(w)
                }</span>
        }
}

func (e Example) result() string <span class="cov8" title="1">{
        switch e </span>{
        case Cmd:<span class="cov8" title="1">
                return cmd()</span>
        case Examples:<span class="cov8" title="1">
                return examples()</span>
        case Table:<span class="cov8" title="1">
                return table()</span>
        case Info:<span class="cov8" title="1">
                return info()</span>
        case View:<span class="cov8" title="1">
                return view()</span>
        case Dump:<span class="cov0" title="0">
                return dump()</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func cmd() string <span class="cov8" title="1">{
        s := &amp;strings.Builder{}
        fmt.Fprintf(s, "  %s info %s\n", meta.Bin, Filenames)
        fmt.Fprintf(s, "  %s view %s\n", meta.Bin, Filenames)
        fmt.Fprintf(s, "  %s example\n\n", meta.Bin)
        fmt.Fprintf(s, "  %s list\n", meta.Bin)
        fmt.Fprintf(s, "  %s tables\n", meta.Bin)
        fmt.Fprintf(s, "  %s table [code page names or aliases]\n", meta.Bin)
        fmt.Fprintf(s, "  %s lang", meta.Bin)
        return s.String()
}</span>

func examples() string <span class="cov8" title="1">{
        s := &amp;strings.Builder{}
        fmt.Fprintf(s, "  %s examples\t\t# list the builtin examples\n", meta.Bin)
        fmt.Fprintf(s, "  %s info ascii\t\t# information on the buildin ascii sample\n", meta.Bin)
        fmt.Fprintf(s, "  %s info ascii -f json\t# information in json format on the ascii sample\n", meta.Bin)
        fmt.Fprintf(s, "  %s view ascii\t\t# view the ascii example\n", meta.Bin)
        fmt.Fprintf(s, "  %s info ansi.rgb\t# information on the 24-bit color ansi example\n", meta.Bin)
        fmt.Fprintf(s, "  %s view ansi.rgb\t# view the 24-bit color ansi example", meta.Bin)
        return s.String()
}</span>

func table() string <span class="cov8" title="1">{
        s := &amp;strings.Builder{}
        fmt.Fprintf(s, "  %s table cp437\n", meta.Bin)
        fmt.Fprintf(s, "  %s table cp437 latin1 windows-1252\n", meta.Bin)
        fmt.Fprintf(s, "  %s table iso-8859-15\n", meta.Bin)
        fmt.Fprintf(s, "  %s list\t# list the supported code page tables\n", meta.Bin)
        return s.String()
}</span>

func info() string <span class="cov8" title="1">{
        s := &amp;strings.Builder{}
        fmt.Fprintf(s, "  %s info text.asc logo.jpg      # print the information of multiple files\n", meta.Bin)
        fmt.Fprintf(s, "  %s info file.txt --format json # print the information using a structured syntax\n", meta.Bin)
        return s.String()
}</span>

func view() string <span class="cov8" title="1">{
        s := &amp;strings.Builder{}
        fmt.Fprintf(s, "  %s view file.txt -i latin1\n", meta.Bin)
        fmt.Fprintf(s, "  %s view file1.txt file2.txt --input \"iso-8859-1\"\n", meta.Bin)
        fmt.Fprintf(s, "  cat file.txt | %s view", meta.Bin)
        return s.String()
}</span>

func dump() string <span class="cov0" title="0">{
        s := &amp;strings.Builder{}
        fmt.Fprintf(s, "  %s dump file.txt\n", meta.Bin)
        fmt.Fprintf(s, "  %s dump file1.txt file2.txt\n", meta.Bin)
        fmt.Fprintf(s, "  cat file.txt | %s dump", meta.Bin)
        return s.String()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package cmd

import (
        "github.com/bengarrett/retrotxtgo/cmd/hexa"
        "github.com/bengarrett/retrotxtgo/cmd/internal/flag"
        "github.com/spf13/cobra"
)

func Dec() *cobra.Command <span class="cov8" title="1">{
        s := "Conversion of decimal to hexadecimal numbers"
        l := `Rudimentary decimal to hexadecimal conversions.

Convert one or a series of decimal numbers to their hexadecimal, base 16 values.
For example the number "255" is converted to "FF".
The number "9" is returned as "9".

No prefixes or leading characters are added to the hexadecimal numbers.
Negative signs should not be used as they could be interpreted as
a command flag.
`
        return &amp;cobra.Command{
                Use:     "dec",
                Aliases: []string{"d"},
                Short:   s,
                Long:    l,
                GroupID: IDcodepage,
                Example: `  retrotxt dec 0 255 106 161`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) == 0 </span><span class="cov0" title="0">{
                                return cmd.Help()
                        }</span>
                        <span class="cov0" title="0">const base = 10
                        if flag.Hex.Raw </span><span class="cov0" title="0">{
                                return hexa.Parser(cmd.OutOrStdout(), base, args...)
                        }</span>
                        <span class="cov0" title="0">return hexa.Writer(cmd.ErrOrStderr(), base, args...)</span>
                },
        }
}

func Hex() *cobra.Command <span class="cov8" title="1">{
        s := "Conversion of hexadecimal to decimal numbers"
        l := `Rudimentary hexadecimal to decimal conversions.

Convert one or a series of hexadecimal numbers to their decimal, base 10 values.
For example the hexadecimal number "FF" is converted to "255".
The hexadecimal number "55" is returned as "85".
The hexadecimal number "09" is converted to "9".

Common, case insensitive, hexadecimal prefixes are stripped.
  - x prefix (x00)
  - # hash prefix, found in CSS (#000)
  - $ dollar prefix, found in retro microcomputers ($00)
  - U+ unicode prefix, used in unicode (U+0000)
  - 0x zero prefix, found in linux and unix C syntax (0x00)
  - \x escape prefix, found in programming languages (\x00)

Numeric character reference (NCR) syntax is also supported.
  - &amp;#000; decimal NCR syntax
  - &amp;#x00; hexadecimal NCR syntax

Any signs are ignored. If a string is not a hexadecimal number then the 
value is printed as "invalid".
`
        return &amp;cobra.Command{
                Use:     "hex",
                Aliases: []string{"h", "x"},
                Short:   s,
                Long:    l,
                GroupID: IDcodepage,
                Example: `  retrotxt hex 0x00 xff U+006A a1`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if len(args) == 0 </span><span class="cov0" title="0">{
                                return cmd.Help()
                        }</span>
                        <span class="cov0" title="0">const base = 16
                        if flag.Hex.Raw </span><span class="cov0" title="0">{
                                return hexa.Parser(cmd.OutOrStdout(), base, args...)
                        }</span>
                        <span class="cov0" title="0">return hexa.Writer(cmd.ErrOrStderr(), base, args...)</span>
                },
        }
}

func DecInit() *cobra.Command <span class="cov8" title="1">{
        const s = "raw output only returns the space separated results"
        d := Dec()
        d.Flags().BoolVarP(&amp;flag.Hex.Raw, "raw", "r", false, s)
        return d
}</span>

func HexInit() *cobra.Command <span class="cov8" title="1">{
        const s = "raw output only returns the space separated results"
        h := Hex()
        h.Flags().BoolVarP(&amp;flag.Hex.Raw, "raw", "r", false, s)
        return h
}</span>

func init() <span class="cov8" title="1">{
        Cmd.AddCommand(DecInit(), HexInit())
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package hexa provides rudimental hexadecimal conversion functions.
package hexa

import (
        "fmt"
        "io"
        "math"
        "strconv"
        "strings"
)

// Base is the number base system for the conversion.
type Base int

const (
        Base10 Base = 10 // Base10 is the decimal number base system.
        Base16 Base = 16 // Base16 is the hexadecimal number base system.
)

// Hexadecimal prefix identifiers.
const (
        X    = "X"   // common
        Hash = "#"   // cascading style sheets colors
        Doll = "$"   // retro microcomputers
        U    = "U+"  // unicode
        Zero = "0X"  // linux and unix C syntax
        Esc  = "\\X" // escape
)

// TrimIdent trims the hexadecimal prefix identifiers and
// returns the hexadecimal value as an upper case string.
func TrimIdent(s string) string <span class="cov8" title="1">{
        s = strings.ToUpper(s)
        s = strings.TrimPrefix(s, X)
        s = strings.TrimPrefix(s, Hash)
        s = strings.TrimPrefix(s, Doll)
        s = strings.TrimPrefix(s, U)
        s = strings.TrimPrefix(s, Zero)
        s = strings.TrimPrefix(s, Esc)
        return s
}</span>

// TrimNCR trims the numeric character reference prefix and suffix,
// and returns a decimal integer as a string.
// If the string is not in NCR syntax, then the original string is returned.
func TrimNCR(s string) string <span class="cov8" title="1">{
        const dec, suffix = "&amp;#", ";"
        x := strings.ToUpper(s)
        if !strings.HasPrefix(x, dec) || !strings.HasSuffix(x, suffix) </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">x = strings.TrimPrefix(x, dec)
        x = strings.TrimSuffix(x, suffix)
        if x == "" </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov8" title="1">return x</span>
}

// TrimIndents trims the hexadecimal prefix identifiers and
// returns the hexadecimal values as upper case strings.
func TrimIndents(vals ...string) []string <span class="cov8" title="1">{
        s := make([]string, len(vals))
        for i, val := range vals </span><span class="cov8" title="1">{
                s[i] = TrimIdent(val)
        }</span>
        <span class="cov8" title="1">for i, val := range s </span><span class="cov8" title="1">{
                s[i] = TrimNCR(val)
        }</span>
        <span class="cov8" title="1">return s</span>
}

// Parse converts the provided strings to based unsigned ints.
// If a string is not a valid integer then the value is -1.
func Parse(b Base, vals ...string) []int64 <span class="cov8" title="1">{
        n := make([]int64, len(vals))
        for i, val := range vals </span><span class="cov8" title="1">{
                x, err := strconv.ParseInt(val, int(b), 64)
                if err != nil </span><span class="cov8" title="1">{
                        n[i] = -1
                        continue</span>
                }
                <span class="cov8" title="1">x = int64(math.Abs(float64(x))) // remove sign
                n[i] = x</span>
        }
        <span class="cov8" title="1">return n</span>
}

// Parser writes the hexadecimal values of the provided decimal strings.
// Only the results are written and are separated by a space.
// If a string is not a hexadecimal number then the value is printed as "NaN".
func Parser(w io.Writer, b Base, vals ...string) error <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">const pad = " "
        sb := &amp;strings.Builder{}
        nums := []int64{}
        switch b </span>{
        case Base10:<span class="cov8" title="1">
                nums = Parse(b, vals...)</span>
        case Base16:<span class="cov8" title="1">
                nums = Parse(b, TrimIndents(vals...)...)</span>
        }
        <span class="cov8" title="1">for _, x := range nums </span><span class="cov8" title="1">{
                if x == -1 </span><span class="cov8" title="1">{
                        fmt.Fprintf(sb, "NaN%s", pad)
                        continue</span>
                }
                <span class="cov8" title="1">switch b </span>{
                case Base10:<span class="cov8" title="1">
                        fmt.Fprintf(sb, "%X%s", x, pad)</span>
                case Base16:<span class="cov8" title="1">
                        fmt.Fprintf(sb, "%d%s", x, pad)</span>
                }
        }
        <span class="cov8" title="1">fmt.Fprint(w, strings.TrimSpace(sb.String()))
        fmt.Fprintln(w)
        return nil</span>
}

// Writer the hexadecimal values of the provided decimal strings.
// If a string is not a hexadecimal number then the value is printed as "invalid".
func Writer(w io.Writer, b Base, vals ...string) error <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">const pad = "  "
        sb := &amp;strings.Builder{}
        nums := []int64{}
        switch b </span>{
        case Base10:<span class="cov8" title="1">
                nums = Parse(b, vals...)</span>
        case Base16:<span class="cov8" title="1">
                nums = Parse(b, TrimIndents(vals...)...)</span>
        }
        <span class="cov8" title="1">for i, x := range nums </span><span class="cov8" title="1">{
                if i &gt;= len(vals) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">s := strings.ToUpper(vals[i])
                if x == -1 </span><span class="cov8" title="1">{
                        fmt.Fprintf(sb, "%s = invalid%s", s, pad)
                        continue</span>
                }
                <span class="cov8" title="1">switch b </span>{
                case Base10:<span class="cov8" title="1">
                        fmt.Fprintf(sb, "%s = %X%s", s, x, pad)</span>
                case Base16:<span class="cov8" title="1">
                        fmt.Fprintf(sb, "%s = %d%s", s, x, pad)</span>
                }
        }
        <span class="cov8" title="1">fmt.Fprint(w, strings.TrimSpace(sb.String()))
        fmt.Fprintln(w)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
        "strings"

        "github.com/bengarrett/retrotxtgo/cmd/example"
        "github.com/bengarrett/retrotxtgo/cmd/internal/flag"
        "github.com/bengarrett/retrotxtgo/cmd/internal/format"
        "github.com/bengarrett/retrotxtgo/cmd/internal/info"
        "github.com/bengarrett/retrotxtgo/term"
        "github.com/spf13/cobra"
)

const infoLong = `Discover details and information about any text or text art file.

The info command will return the following information about a text file:

- slug                        A URL friendly version of the filename.
- filename                The filename.
- filetype                The file type or function, such as plain text file.
- Unicode                Whether the file is readable as Unicode.
- line break                The line break type in use, such as CRLF.
- characters                The number of characters in the file.
- words                        The number of words in the file.
- size                        The file size in a human readable format.
- lines                        The number of lines in the file determined by the line breaks.
- width                        The widest line in the file.
- modified                The date and time the file was last modified.
- media type                The IANA media type, such as text/plain.
- SHA256 check                The SHA256 integrity checksum of the file.
- CRC64                        The cyclic redundancy check of the file.
- CRC32                        The cyclic redundancy check of the file.
- MD5                        The MD5 hash of the file.

Art scene files embedded with SAUCE metadata will also return the 
following information:

- title                        The title of the file.
- author                The nickname or handle of the file creator.
- group                        The group or company of the author.
- date                        The date the file was created.
- original size                The size of the file without the SAUCE metadata.
- file type                The specific type of the file, such as PNG image.
- data type                The media type of the file, such as a bitmap image.
- description                The description of file and data type.
- character width        The number of characters per line.
- number of lines        The number of lines in the file.
- interpretation        Additional information about the file types.
- comments                Additional comments by the author.

The full SAUCE specification can be found at:
https://www.acid.org/info/sauce/sauce.htm`

func InfoCommand() *cobra.Command <span class="cov8" title="1">{
        s := "Information on text files"
        expl := strings.Builder{}
        example.Info.String(&amp;expl)
        return &amp;cobra.Command{
                Use:     "info " + example.Filenames,
                Aliases: []string{"i"},
                GroupID: IDfile,
                Short:   s,
                Long:    infoLong,
                Example: expl.String(),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        return info.Run(cmd.OutOrStdout(), cmd, args...)
                }</span>,
        }
}

func InfoInit() *cobra.Command <span class="cov8" title="1">{
        ic := InfoCommand()
        s := &amp;strings.Builder{}
        infos := format.Format().Info
        term.Options(s, "print format or syntax", true, true, infos[:]...)
        ic.Flags().StringVarP(&amp;flag.Info.Format, "format", "f", "color", s.String())
        ic.Flags().BoolVarP(&amp;flag.Info.Checksum, "checksum", "c", false,
                "also include redundant checksums such as MD5 and CRC")
        return ic
}</span>

func init() <span class="cov8" title="1">{
        Cmd.AddCommand(InfoInit())
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package dump

import (
        "encoding/hex"
        "errors"
        "fmt"
        "io"

        "github.com/bengarrett/retrotxtgo/cmd/internal/flag"
        "github.com/bengarrett/retrotxtgo/fsys"
        "github.com/bengarrett/retrotxtgo/term"
        "github.com/spf13/cobra"
)

var ErrPipeRead = errors.New("could not read text stream from piped stdin (standard input)")

// Run parses the arguments supplied with the view command.
func Run(w io.Writer, cmd *cobra.Command, args ...string) error <span class="cov0" title="0">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        // piped input from other programs and then exit
        <span class="cov0" title="0">ok, err := fsys.IsPipe()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                return Pipe(w)
        }</span>
        // read from files or samples
        <span class="cov0" title="0">args, c, samp, err := flag.Args(cmd, args...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for i, arg := range args </span><span class="cov0" title="0">{
                if i == 0 &amp;&amp; arg == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if i &gt; 0 &amp;&amp; i &lt; len(arg) </span><span class="cov0" title="0">{
                        const page = 76
                        term.HR(w, page)
                }</span>
                <span class="cov0" title="0">b, err := flag.ReadArgument(arg, c, samp)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">fmt.Fprint(w, hex.Dump(b))</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Pipe parses a standard input (stdin) stream of data.
func Pipe(w io.Writer) error <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">data, err := fsys.ReadPipe()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w, %w", ErrPipeRead, err)
        }</span>
        <span class="cov0" title="0">fmt.Fprint(w, hex.Dump(data))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package flag provides the command flags handlers.
package flag

import (
        "errors"
        "fmt"
        "os"
        "slices"
        "strconv"
        "strings"

        "github.com/bengarrett/retrotxtgo/convert"
        "github.com/bengarrett/retrotxtgo/fsys"
        "github.com/bengarrett/retrotxtgo/logs"
        "github.com/bengarrett/retrotxtgo/sample"
        "github.com/spf13/cobra"
        "golang.org/x/text/encoding"
        "golang.org/x/text/encoding/charmap"
        "golang.org/x/text/encoding/unicode"
)

var (
        ErrInput = errors.New("empty default encoding")
        ErrNames = errors.New("ignoring [filenames]")
)

// Args initializes the command arguments and flags.
func Args(cmd *cobra.Command, args ...string) (
        []string, *convert.Convert, sample.Flags, error,
) <span class="cov0" title="0">{
        reset := []string{}
        converter := convert.Convert{}
        converter.Args = convert.Flag{
                Controls:  View().Controls,
                SwapChars: View().Swap,
                MaxWidth:  View().Width,
        }
        converter.Args = setFlags(cmd, converter.Args)
        pipeOW, err := fsys.IsPipe()
        if err != nil </span><span class="cov0" title="0">{
                logs.Fatal(err)
        }</span>
        <span class="cov0" title="0">if pipeOW </span><span class="cov0" title="0">{
                converter.Input.Encoding = unicode.UTF16(unicode.LittleEndian, unicode.UseBOM)
                args = reset
        }</span> else<span class="cov0" title="0"> {
                err := Help(cmd, args...)
                if err != nil </span><span class="cov0" title="0">{
                        logs.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">count := len(args)
        if pipeOW &amp;&amp; count &gt; 0 </span><span class="cov0" title="0">{
                err := fmt.Errorf("%w;%w for piped text", err, ErrNames)
                fmt.Fprintln(os.Stderr, logs.Sprint(err))
                args = reset
        }</span>
        <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                args = reset
        }</span>
        <span class="cov0" title="0">inputsOW, err := InputOverride(cmd, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, inputsOW, err
        }</span>
        // despite this default cp437 encoding being set,
        // the results of the --input flag will be used
        // when provided in the inputsOW struct.
        <span class="cov0" title="0">if converter.Input.Encoding == nil </span><span class="cov0" title="0">{
                converter.Input.Encoding = Default()
        }</span>
        <span class="cov0" title="0">return args, &amp;converter, inputsOW, nil</span>
}

// setFlags applies the flag arguments to a convert flag struct.
func setFlags(cmd *cobra.Command, flag convert.Flag) convert.Flag <span class="cov0" title="0">{
        const (
                controls  = "controls"
                swapChars = "swap-chars"
                width     = "width"
        )
        if c := cmd.Flags().Lookup(controls); c != nil &amp;&amp; c.Changed </span><span class="cov0" title="0">{
                const sep, minChrs = ",", 2
                val := c.Value.String()
                if len(val) &gt; minChrs </span><span class="cov0" title="0">{
                        val = val[1 : len(val)-1]
                }</span>
                <span class="cov0" title="0">ctrls := strings.Split(val, sep)
                flag.Controls = ctrls</span>
        }
        <span class="cov0" title="0">if s := cmd.Flags().Lookup(swapChars); s != nil &amp;&amp; s.Changed </span><span class="cov0" title="0">{
                const sep, minChrs = ",", 2
                val := s.Value.String()
                if len(val) &gt; minChrs </span><span class="cov0" title="0">{
                        val = val[1 : len(val)-1]
                }</span>
                <span class="cov0" title="0">swaps := strings.Split(val, sep)
                flag.SwapChars = swaps</span>
        }
        <span class="cov0" title="0">if w := cmd.Flags().Lookup(width); w != nil &amp;&amp; w.Changed </span><span class="cov0" title="0">{
                i, err := strconv.Atoi(w.Value.String())
                if err != nil </span><span class="cov0" title="0">{
                        logs.Fatal(err)
                }</span>
                <span class="cov0" title="0">flag.MaxWidth = i</span>
        }
        <span class="cov0" title="0">return flag</span>
}

// Default returns a default encoding when the "input" flag is unused.
// If the input is a pipe, then the default encoding is UTF-16.
// Otherwise, the default encoding is CodePage437.
func Default() encoding.Encoding <span class="cov8" title="1">{
        pipeOW, err := fsys.IsPipe()
        if err != nil </span><span class="cov0" title="0">{
                logs.Fatal(err)
        }</span>
        <span class="cov8" title="1">if pipeOW </span><span class="cov0" title="0">{
                return unicode.UTF16(unicode.LittleEndian, unicode.UseBOM)
        }</span>
        <span class="cov8" title="1">return charmap.CodePage437</span>
}

// InputOverride applies the "input" encoding flag and the "original" bool flag.
func InputOverride(cmd *cobra.Command, fallback string) (sample.Flags, error) <span class="cov8" title="1">{
        none := sample.Flags{}
        if cmd == nil </span><span class="cov8" title="1">{
                return none, nil
        }</span>
        <span class="cov0" title="0">const input, original = "input", "original"
        // handle encode flag or apply the default
        cp := cmd.Flags().Lookup(input)
        in, err := parseInput(cp.Changed, cp.Value.String(), fallback)
        // parse("input")
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, ErrInput) </span><span class="cov0" title="0">{
                        return none, nil
                }</span>
                <span class="cov0" title="0">return none, err</span>
        }
        // handle the hidden original bool flag
        <span class="cov0" title="0">og := false
        l := cmd.Flags().Lookup(original)
        if l != nil &amp;&amp; l.Changed </span><span class="cov0" title="0">{
                og = true
        }</span>
        <span class="cov0" title="0">return sample.Flags{Input: in, Original: og}, nil</span>
}

func parseInput(changed bool, value, fallback string) (encoding.Encoding, error) <span class="cov0" title="0">{
        name := fallback
        if changed </span><span class="cov0" title="0">{
                name = value
        }</span>
        // 11-Aug-25, this was previously bugged with an OR statement,
        // it must always be an AND condition otherwise the logic will break.
        <span class="cov0" title="0">if name == "" &amp;&amp; fallback == "" </span><span class="cov0" title="0">{
                return nil, ErrInput
        }</span>
        <span class="cov0" title="0">return convert.Encoder(name)</span>
}

// EndOfFile reports whether end-of-file control flag was requested.
func EndOfFile(flags convert.Flag) bool <span class="cov8" title="1">{
        return slices.Contains(flags.Controls, "eof")
}</span>

// Help will print the help and exit when no arguments are supplied.
func Help(cmd *cobra.Command, args ...string) error <span class="cov0" title="0">{
        if len(args) != 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return cmd.Help()</span>
}

// OpenSample returns the content of the named embed sample file given via an argument.
func OpenSample(name string, c *convert.Convert, f sample.Flags) ([]byte, error) <span class="cov0" title="0">{
        if ok := sample.Valid(name); !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        // return the sample with the original encoding
        <span class="cov0" title="0">if f.Original </span><span class="cov0" title="0">{
                p, err := sample.Open(name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return p, nil</span>
        }
        // return the sample with utf-8 encoding
        <span class="cov0" title="0">r, err := f.Open(c, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return []byte(string(r)), nil</span>
}

// ReadArgument returns the content of argument supplied filepath, embed sample file or piped data.
func ReadArgument(arg string, c *convert.Convert, f sample.Flags) ([]byte, error) <span class="cov0" title="0">{
        // attempt to see if arg is a embed sample file request
        b, err := OpenSample(arg, c, f)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov0" title="0"> if b != nil </span><span class="cov0" title="0">{
                return b, nil
        }</span>
        // the arg should be a filepath
        <span class="cov0" title="0">b, err = fsys.Read(arg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return b, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package flag provides the command flags handlers.
package flag

import (
        "errors"
        "fmt"

        "github.com/bengarrett/retrotxtgo/meta"
        "github.com/bengarrett/retrotxtgo/term"
        "github.com/spf13/cobra"
)

var ErrHide = errors.New("could not hide the flag")

// Command flags for the main cmd.
type Command struct {
        Tester bool // internal automated tester
}

// Cmd returns the flags for the main cmd.
var Cmd Command

// Hex handles the dec and hex "raw" flag.
var Hex struct {
        Raw bool // raw output
}

// Info handles the info "format" flag.
var Info struct {
        Checksum bool   // show legacy checksums
        Format   string // output format
}

// Views handles the view command flags.
type Views struct {
        Input    string   // input character encoding used by the files
        Controls []string // control codes to implement
        Swap     []string // swap out these characters with Unicode control pictures
        Width    int      // maximum document character/column width
        Original bool     // output the sample's original character encoding to stdout
}

// View returns the Views struct with default values.
func View() Views <span class="cov8" title="1">{
        return Views{
                Input:    "CP437",
                Controls: []string{"eof", "tab"},
                Swap:     []string{"null", "bar"},
                Width:    0,
                Original: false,
        }
}</span>

// Controls handles the "controls" flag.
func Controls(p *[]string, cc *cobra.Command) <span class="cov0" title="0">{
        cc.Flags().StringSliceVarP(p, "controls", "c", []string{},
                `implement these control codes (default "eof,tab")`+
                        `
  separate multiple controls with commas
  eof    end of file mark
  tab    horizontal tab
  bell   audio terminal alert
  cr     carriage return
  lf     line feed
  bs backspace, del delete character, esc escape character
  ff formfeed, vt vertical tab
`)
}</span>

// Encode handles the "input" flag.
func Encode(p *string, cc *cobra.Command) <span class="cov0" title="0">{
        cc.Flags().StringVarP(p, "input", "i", "",
                fmt.Sprintf("character encoding used by the filename(s) (default \"CP437\")\n%s%s\n%s\n",
                        "see the list of encode values ",
                        term.Example(meta.Bin+" list codepages"),
                        "this flag has no effect for the inbuilt samples"))
}</span>

// SwapChars handles the "swap-chars" flag.
func SwapChars(p *[]string, cc *cobra.Command) <span class="cov0" title="0">{
        cc.Flags().StringSliceVarP(p, "swap-chars", "x", []string{},
                `swap out these characters with common alternatives (default "null,bar")
  separate multiple values with commas
  null        C null for a space
  bar        Unicode vertical bar | for the IBM broken pipe 
  house        IBM house  for the Greek capital delta 
  pipe        Box pipe  for the Unicode integral extension 
  root        Square root  for the Unicode check mark 
  space        Space for the Unicode open box 
  `)
}</span>

// OG handles the original flag that can be used for multiple commands.
func OG(p *bool, cc *cobra.Command) error <span class="cov0" title="0">{
        const name = "original"
        cc.Flags().BoolVar(p, name, false,
                "use the original document character encoding to print to terminal"+
                        "\nby default, "+meta.Bin+" view always prints texts as UTF-8"+
                        "\nthis flag only works with the inbuilt samples\n")
        return nil
}</span>

// Width handles the "width" flag.
func Width(p *int, cc *cobra.Command) <span class="cov0" title="0">{
        cc.Flags().IntVarP(p, "width", "w", View().Width,
                `maximum document character/column width
any horizontal tab characters are replaced with three spaces
any newline characters are replaced with a space
`)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package format handles the text output, syntax options.
package format

// Syntax choices for the input format flag.
type Syntax struct {
        Info [5]string
}

// Format flag choices for the info command.
func Format() Syntax <span class="cov8" title="1">{
        return Syntax{
                Info: [5]string{"color", "json", "json.min", "text", "xml"},
        }
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// Package info provides the info command run function.
package info

import (
        "errors"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/bengarrett/retrotxtgo/cmd/internal/flag"
        "github.com/bengarrett/retrotxtgo/fsys"
        "github.com/bengarrett/retrotxtgo/info"
        "github.com/bengarrett/retrotxtgo/sample"
        "github.com/spf13/cobra"
)

var (
        ErrNotExist  = errors.New("no such file or directory")
        ErrNotSamp   = errors.New("no such example or sample file")
        ErrInfo      = errors.New("could not any obtain information")
        ErrUsage     = errors.New("command usage could not display")
        ErrPipeRead  = errors.New("could not read text stream from piped stdin (standard input)")
        ErrPipeParse = errors.New("could not parse the text stream from piped stdin (standard input)")
        ErrTmpClose  = errors.New("could not close the temporary file")
        ErrTmpOpen   = errors.New("could not open the temporary file")
        ErrTmpSave   = errors.New("could not save to the temporary file")
)

// Run parses the arguments supplied with the info command.
func Run(w io.Writer, cmd *cobra.Command, args ...string) error <span class="cov0" title="0">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        // piped input from other programs and then exit
        <span class="cov0" title="0">ok, err := fsys.IsPipe()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                return Pipe(w)
        }</span>
        <span class="cov0" title="0">if err := flag.Help(cmd, args...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, arg := range args </span><span class="cov0" title="0">{
                _, err := os.Stat(arg)
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // embed sample filename
                        filename, err := Sample(arg)
                        if errors.Is(err, ErrNotSamp) </span><span class="cov0" title="0">{
                                return fmt.Errorf("%w, %w: %s", ErrInfo, err, arg)
                        }</span>
                        <span class="cov0" title="0">if filename == "" </span><span class="cov0" title="0">{
                                return ErrNotExist
                        }</span>
                        <span class="cov0" title="0">defer os.Remove(filename)
                        arg = filename</span>
                }
                <span class="cov0" title="0">switch flag.Info.Format </span>{
                case "color", "c", "", "text", "t":<span class="cov0" title="0">
                        fmt.Fprintln(w)</span>
                }
                <span class="cov0" title="0">err = info.Info(w, arg, flag.Info.Format, flag.Info.Checksum)
                if err != nil </span><span class="cov0" title="0">{
                        if err := cmd.Usage(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%w: %w", ErrUsage, err)
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Sample extracts and saves the named embed sample file then returns the filepath.
func Sample(name string) (string, error) <span class="cov8" title="1">{
        s := strings.ToLower(name)
        samp, exist := sample.Map()[s]
        if !exist </span><span class="cov8" title="1">{
                return "", ErrNotSamp
        }</span>
        <span class="cov8" title="1">b, err := sample.File.ReadFile(samp.Name)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf(" sample file %q: %w", samp.Name, err)
        }</span>
        <span class="cov8" title="1">file, err := os.CreateTemp("", fmt.Sprintf("retrotxt_%s.*.txt", s))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf(" sample file %q: %w", samp.Name, ErrTmpOpen)
        }</span>
        <span class="cov8" title="1">defer file.Close()
        if _, err = file.Write(b); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf(" sample file %q: %w", samp.Name, ErrTmpSave)
        }</span>
        <span class="cov8" title="1">return file.Name(), nil</span>
}

// Pipe parses a standard input (stdin) stream of data.
func Pipe(w io.Writer) error <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">b, err := fsys.ReadPipe()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w, %w", ErrPipeRead, err)
        }</span>
        <span class="cov0" title="0">err = info.Stream(w, flag.Info.Format, b...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w, %w", ErrPipeParse, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package view provides the view command run function.
package view

import (
        "errors"
        "fmt"
        "io"
        "unicode/utf8"

        "github.com/bengarrett/retrotxtgo/cmd/internal/flag"
        "github.com/bengarrett/retrotxtgo/convert"
        "github.com/bengarrett/retrotxtgo/fsys"
        "github.com/bengarrett/retrotxtgo/term"
        "github.com/spf13/cobra"
        "golang.org/x/text/encoding"
)

var (
        ErrConv     = errors.New("convert cannot be nil")
        ErrPipeRead = errors.New("could not read text stream from piped stdin (standard input)")
)

// Run parses the arguments supplied with the view command.
func Run(w io.Writer, cmd *cobra.Command, args ...string) error <span class="cov0" title="0">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        // piped input from other programs and then exit
        <span class="cov0" title="0">ok, err := fsys.IsPipe()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                return Pipe(w, cmd, args...)
        }</span>
        // read from files or samples
        <span class="cov0" title="0">args, c, samp, err := flag.Args(cmd, args...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for i, arg := range args </span><span class="cov0" title="0">{
                if i == 0 &amp;&amp; arg == "" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if i &gt; 0 &amp;&amp; i &lt; len(arg) </span><span class="cov0" title="0">{
                        const halfPage = 40
                        fmt.Fprintln(w)
                        term.HR(w, halfPage)
                }</span>
                <span class="cov0" title="0">b, err := flag.ReadArgument(arg, c, samp)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // write out the sample with its original encoding
                // this could display poorly in a terminal
                <span class="cov0" title="0">if samp.Original </span><span class="cov0" title="0">{
                        fmt.Fprint(w, string(b))
                        continue</span>
                }
                // write out the sample with the utf-8 encoding
                <span class="cov0" title="0">r, err := Transform(c, samp.Input, nil, b...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">fmt.Fprint(w, string(r))</span>
        }
        <span class="cov0" title="0">fmt.Fprintln(w)
        return nil</span>
}

// Pipe parses a standard input (stdin) stream of data.
func Pipe(w io.Writer, cmd *cobra.Command, args ...string) error <span class="cov0" title="0">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        <span class="cov0" title="0">_, c, samp, err := flag.Args(cmd, args...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">b, err := fsys.ReadPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w, %w", ErrPipeRead, err)
        }</span>
        // write out the sample with the utf-8 encoding
        <span class="cov0" title="0">r, err := Transform(c, samp.Input, nil, b...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fmt.Fprint(w, string(r))
        return nil</span>
}

// Transform bytes into Unicode runes.
// The optional in encoding argument is the bytes original character encoding.
// The optional out encoding argument is the encoding to replicate.
// When no encoding arguments are provided, UTF-8 unicode encoding is used.
func Transform(c *convert.Convert, in, out encoding.Encoding, b ...byte,
) ([]rune, error) <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return nil, ErrConv
        }</span>
        <span class="cov8" title="1">var err error
        if b == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        // handle input source encoding
        <span class="cov8" title="1">if in != nil </span><span class="cov8" title="1">{
                c.Input.Encoding = in
        }</span>
        <span class="cov8" title="1">p := b
        // handle any encoding BEFORE outputting to Unicode
        // we also make sure the bytes are not valid UTF-8
        // otherwise the bytes will become corrupted
        if out != nil &amp;&amp; !utf8.Valid(b) </span><span class="cov0" title="0">{
                p, err = out.NewDecoder().Bytes(b)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        // convert the bytes into runes
        <span class="cov8" title="1">if flag.EndOfFile(c.Args) </span><span class="cov0" title="0">{
                return c.Text(p...)
        }</span>
        <span class="cov8" title="1">return c.Dump(p...)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cmd

import (
        "github.com/bengarrett/retrotxtgo/table"
        "github.com/spf13/cobra"
)

func Language() *cobra.Command <span class="cov8" title="1">{
        s := "List the natural languages of legacy code pages"
        l := "List the natural languages and writing alphabets of legacy code pages."
        return &amp;cobra.Command{
                Use:     "lang",
                Aliases: []string{"la", "language"},
                Short:   s,
                Long:    l,
                GroupID: IDcodepage,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return table.ListLanguage(cmd.OutOrStdout())
                }</span>,
        }
}

func init() <span class="cov8" title="1">{
        Cmd.AddCommand(Language())
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package cmd

import (
        "fmt"

        "github.com/bengarrett/retrotxtgo/meta"
        "github.com/bengarrett/retrotxtgo/table"
        "github.com/spf13/cobra"
)

func ListCodepage() *cobra.Command <span class="cov8" title="1">{
        s := fmt.Sprintf("List the legacy code pages that %s can convert to UTF-8", meta.Name)
        l := fmt.Sprintf("List the available legacy code pages that %s can convert to UTF-8.", meta.Name)
        return &amp;cobra.Command{
                Use:     "list",
                Aliases: []string{"l", "cp", "codepage"},
                Short:   s,
                Long:    l,
                GroupID: IDcodepage,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return table.List(cmd.OutOrStdout())
                }</span>,
        }
}

func init() <span class="cov8" title="1">{
        Cmd.AddCommand(ListCodepage())
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">// Package list provides the list command run function.
package list

import (
        "errors"
        "fmt"
        "io"
        "slices"
        "sort"
        "strings"
        "text/tabwriter"

        "github.com/bengarrett/retrotxtgo/meta"
        "github.com/bengarrett/retrotxtgo/sample"
        "github.com/bengarrett/retrotxtgo/table"
        "github.com/bengarrett/retrotxtgo/term"
        "github.com/bengarrett/retrotxtgo/xud"
        "golang.org/x/text/encoding"
        "golang.org/x/text/encoding/charmap"
        "golang.org/x/text/encoding/ianaindex"
        "golang.org/x/text/encoding/traditionalchinese"
)

var (
        ErrTable = errors.New("could not display the table")
        ErrIANA  = errors.New("could not work out the IANA index or MIME type")
)

// Examples writes the list command examples.
func Examples(wr io.Writer) error <span class="cov8" title="1">{
        if wr == nil </span><span class="cov0" title="0">{
                wr = io.Discard
        }</span>
        <span class="cov8" title="1">const width = 80
        m := sample.Map()
        keys := make([]string, 0, len(m))
        for k := range m </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)
        const padding = 2
        w := tabwriter.NewWriter(wr, 0, 0, padding, ' ', 0)
        bin := fmt.Sprintf("  %s ", meta.Bin)
        header := "Packaged example text and ANSI files to test and play with " + meta.Name
        term.Head(w, width, header)
        fmt.Fprintf(w, "\nAny of these packaged examples will work with the %s and %s commands.\n",
                term.Example("info"), term.Example("view"))
        fmt.Fprintln(w)
        for _, k := range keys </span><span class="cov8" title="1">{
                fmt.Fprintf(w, " %s\t%s\t\n", k, m[k].Description)
        }</span>
        <span class="cov8" title="1">fmt.Fprintln(w)
        term.Head(w, width, "Usage sample commands")
        fmt.Fprintf(w, "\nPrint the Windows-1252 English test to the terminal.\n%s\n",
                term.Example(bin+"view 1252"))
        fmt.Fprintf(w, "\nConvert the Windows-1252 English test to UTF-8 encoding and save it to a file.\n%s\n",
                term.Example(bin+"view 1252 &gt; file.txt"))
        fmt.Fprintf(w, "\nSave the Windows-1252 English test with its original encoding.\n%s\n",
                term.Example(bin+"view 1252 --original &gt; file.txt"))
        fmt.Fprintf(w, "\nDisplay statistics and information from a piped source.\n%s\n",
                term.Example(fmt.Sprintf("%sview 1252 --original | %s info", bin, meta.Bin)))
        fmt.Fprintf(w, "\nDisplay statistics and information from the Windows-1252 English test.\n%s\n",
                term.Example(bin+"info 1252"))
        fmt.Fprintf(w, "\nDisplay statistics, information and SAUCE metadata from the SAUCE test.\n%s\n",
                term.Example(bin+"info sauce"))
        fmt.Fprintf(w, "\nMultiple examples used together are supported.\n%s\n",
                term.Example(bin+"view ansi ascii ansi.rgb"))
        return w.Flush()</span>
}

// Table writes one or more named encodings as a formatted table.
func Table(w io.Writer, names ...string) error <span class="cov8" title="1">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        // custom ascii shortcut
        <span class="cov8" title="1">tables := names
        for i, name := range tables </span><span class="cov8" title="1">{
                if name != "ascii" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if i &gt; len(names) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">names[i] = "ascii-67"
                names = append(names[:i+1], names[i:]...)
                names[i] = "ascii-65"
                names = append(names[:i+1], names[i:]...)
                names[i] = "ascii-63"</span>
        }
        // iterate through the tables
        <span class="cov8" title="1">for _, name := range names </span><span class="cov8" title="1">{
                if err := table.Table(w, name); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">fmt.Fprintln(w)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Tables writes all the supported encodings as formatted tables.
func Tables(w io.Writer) error <span class="cov8" title="1">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        // use strings builder to reduce memory usage
        // https://yourbasic.org/golang/build-append-concatenate-strings-efficiently/
        <span class="cov8" title="1">tables := make([]encoding.Encoding, 0, len(table.Charmaps()))
        encodings := table.Charmaps()
        encodings = append(encodings,
                xud.XUserDefined1963,
                xud.XUserDefined1965,
                xud.XUserDefined1967)
        // reorder tables to position X-User-Defined after ISO-8859-10
        for _, e := range encodings </span><span class="cov8" title="1">{
                switch e </span>{
                case charmap.ISO8859_10:<span class="cov8" title="1">
                        tables = append(tables, charmap.ISO8859_10)
                        tables = append(tables, xud.XUserDefinedISO11)
                        continue</span>
                case xud.XUserDefinedISO11:<span class="cov0" title="0">
                        continue</span>
                }
                <span class="cov8" title="1">tables = append(tables, e)</span>
        }
        <span class="cov8" title="1">tables = slices.Compact(tables)
        // print tables
        for _, e := range tables </span><span class="cov8" title="1">{
                var (
                        err  error
                        name string
                )
                switch e </span>{
                case
                        traditionalchinese.Big5,
                        charmap.XUserDefined:<span class="cov8" title="1">
                        // do not display these encodings
                        continue</span>
                case xud.XUserDefinedISO11:<span class="cov8" title="1">
                        name = fmt.Sprint(e)</span>
                case
                        xud.XUserDefined1963,
                        xud.XUserDefined1965,
                        xud.XUserDefined1967:<span class="cov8" title="1">
                        name = xud.Name(e)</span>
                }
                <span class="cov8" title="1">if name == "" </span><span class="cov8" title="1">{
                        name, err = ianaindex.MIME.Name(e)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("table %s, %w, %w", e, ErrIANA, err)
                        }</span>
                }
                <span class="cov8" title="1">if !Printable(name) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if err := table.Table(w, name); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("table %s, %w, %w", e, ErrTable, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Printable reports whether the named encoding can be shown as
// a 256 character table. UTF-16 and UTF-32 are not printable.
func Printable(name string) bool <span class="cov8" title="1">{
        const (
                utf16 = "utf-16"
                l     = len(utf16)
        )
        s := strings.ToLower(name)
        if s == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if len(s) &lt; l </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if s[:l] == utf16 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if s[:l] == "utf-32" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Package online is for simple HTTP interactions with the GitHub API.
// It is used to fetch the latest release information of the program.
package online

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/bengarrett/retrotxtgo/meta"
)

var (
        ErrJSON   = errors.New("the response body syntax is not json")
        ErrMash   = errors.New("cannot unmarshal the json response body")
        ErrNoResp = errors.New("the response is nil and unusable")
)

const (
        // ReleaseAPI GitHub API v3 releases endpoint.
        // See: https://developer.github.com/v3/repos/releases/
        ReleaseAPI = "https://api.github.com/repos/bengarrett/retrotxtgo/releases/latest"
        timeout    = time.Second * 3
)

// API interface to store the JSON results from GitHub.
type API map[string]any

// Endpoint requests an API endpoint from the URL.
// A HTTP ETag can be provided to validate local data cache against the server.
// It also reports whether the etag value matches the server ETag header.
func Endpoint(url, etag string) (bool, API, error) <span class="cov8" title="1">{
        const msg = "online api endpoint"
        resp, body, err := Get(url, etag)
        if err != nil </span><span class="cov8" title="1">{
                return false, API{}, fmt.Errorf("%s get failed: %w", msg, err)
        }</span>
        <span class="cov0" title="0">if resp == nil </span><span class="cov0" title="0">{
                return false, API{}, fmt.Errorf("%s get: %w", msg, ErrNoResp)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        if etag != "" </span><span class="cov0" title="0">{
                s := resp.StatusCode
                if s == 304 || (s == 200 &amp;&amp; body == nil) </span><span class="cov0" title="0">{
                        // Not Modified
                        return true, API{}, nil
                }</span>
        }
        <span class="cov0" title="0">if ok := json.Valid(body); !ok </span><span class="cov0" title="0">{
                return false, API{}, fmt.Errorf("%s %s: %w", msg, url, ErrJSON)
        }</span>
        <span class="cov0" title="0">var data API
        if err := json.Unmarshal(body, &amp;data); err != nil </span><span class="cov0" title="0">{
                return false, API{}, fmt.Errorf("%s %s: %w", msg, url, ErrMash)
        }</span>
        <span class="cov0" title="0">if data == nil </span><span class="cov0" title="0">{
                return false, API{}, fmt.Errorf("%s %s: %w", msg, url, ErrMash)
        }</span>
        <span class="cov0" title="0">val := resp.Header.Get("Etag")
        data["etag"] = val
        return false, data, nil</span>
}

// Get fetches a URL and returns both its response and body.
// If an etag is provided a "If-None-Match" header request will be included.
func Get(url, etag string) (*http.Response, []byte, error) <span class="cov8" title="1">{
        client := &amp;http.Client{
                Timeout: timeout,
        }
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
        defer cancel()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("getting a new request error: %w", err)
        }</span>
        <span class="cov8" title="1">if etag != "" </span><span class="cov0" title="0">{
                req.Header.Set("If-None-Match", etag)
        }</span>
        <span class="cov8" title="1">req.Header.Set("User-Agent", userAgent())
        resp, err := client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("requesting to set the get user-agent header: %w", err)
        }</span>
        <span class="cov0" title="0">if resp == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("getting response: %w", ErrNoResp)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("reading the response body failed: %w", err)
        }</span>
        <span class="cov0" title="0">return resp, body, nil</span>
}

// Ping requests a URL and reports whether if the status is successful.
// A server response status code between 200 and 299 is considered a success.
func Ping(url string) (bool, error) <span class="cov8" title="1">{
        client := &amp;http.Client{
                Timeout: timeout,
        }
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        req, err := http.NewRequestWithContext(ctx, http.MethodHead, url, nil)
        defer cancel()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("pinging a new request error: %w", err)
        }</span>
        <span class="cov8" title="1">req.Header.Set("User-Agent", userAgent())
        resp, err := client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("requesting to set the ping user-agent header: %w", err)
        }</span>
        <span class="cov0" title="0">if resp == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("ping response: %w", ErrNoResp)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        const ok, maximum = http.StatusOK, 299
        success2xx := resp.StatusCode &gt;= ok &amp;&amp; resp.StatusCode &lt;= maximum
        return success2xx, nil</span>
}

func userAgent() string <span class="cov8" title="1">{
        return meta.Bin + " version ping"
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package cmd

import (
        "strings"

        "github.com/bengarrett/retrotxtgo/cmd/example"
        "github.com/bengarrett/retrotxtgo/cmd/internal/flag"
        "github.com/bengarrett/retrotxtgo/cmd/list"
        "github.com/spf13/cobra"
)

func Table() *cobra.Command <span class="cov8" title="1">{
        s := "Display one or more code page tables showing all the characters in use"
        l := "Display one or more code page tables showing all the characters in use."
        expl := strings.Builder{}
        example.Table.String(&amp;expl)
        return &amp;cobra.Command{
                Use:     "table [code page names or aliases]",
                Aliases: []string{"t"},
                Short:   s,
                Long:    l,
                Example: expl.String(),
                GroupID: IDcodepage,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if err := flag.Help(cmd, args...); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return list.Table(cmd.OutOrStdout(), args...)</span>
                },
        }
}

func Tables() *cobra.Command <span class="cov8" title="1">{
        return &amp;cobra.Command{
                Use:     "tables",
                Short:   "Display the characters of every code page table in use",
                Long:    "Display the characters of every code page table in use.",
                GroupID: IDcodepage,
                RunE: func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                        return list.Tables(cmd.OutOrStdout())
                }</span>,
        }
}

func init() <span class="cov8" title="1">{
        Cmd.AddCommand(Table())
        Cmd.AddCommand(Tables())
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package cmd

import (
        "github.com/bengarrett/retrotxtgo/term"
        "github.com/gookit/color"
)

// init is always called by the Cobra library to be used for global flags and commands.
func init() <span class="cov8" title="1">{
        const highColor, basicColor = "COLORTERM", "TERM"
        if term.Term(term.GetEnv(highColor), term.GetEnv(basicColor)) == "none" </span><span class="cov0" title="0">{
                // disable all color output
                color.Enable = false
        }</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package update provides the ability to check GitHub for the newest release tag.
package update

import (
        "errors"
        "fmt"
        "io"
        "os"

        "github.com/bengarrett/retrotxtgo/cmd/online"
        "github.com/bengarrett/retrotxtgo/fsys"
        "github.com/bengarrett/retrotxtgo/logs"
        "github.com/bengarrett/retrotxtgo/meta"
        "github.com/bengarrett/retrotxtgo/term"
        gap "github.com/muesli/go-app-paths"
        "gopkg.in/yaml.v3"
)

var (
        ErrCacheYaml = errors.New("set cache cannot marshal yaml")
        ErrCacheData = errors.New("set cache cannot create a data path")
        ErrCacheSave = errors.New("set cache cannot save data")
)

// Cache of the newest production release.
// The Etag string is used to check if the release has changed,
// by requesting a tiny HTTP header from the GitHub API instead
// of the full response.
type Cache struct {
        Etag    string `yaml:"etag"`    // http etag header
        Version string `yaml:"version"` // semantic version
}

const cacheFile = "api.github.cache"

// Notice writes a new release notification box and text.
func Notice(w io.Writer, old, current string) <span class="cov0" title="0">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        <span class="cov0" title="0">s := fmt.Sprintf("%s%s%s\n%s%s\n%s  %s",
                "A newer edition of ", meta.Name, " is available!",
                "Learn more at ", meta.URL, meta.Semantic(old), current)
        term.Border(w, s)</span>
}

// Check the GitHub for the newest release tag.
// The returned string will only contain the newest available release tag
// if the local program version is out of date.
func Check() (string, error) <span class="cov0" title="0">{
        if meta.App.Version == meta.GoBuild </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">cache := CacheGet()
        etag, tag := cache.Etag, cache.Version
        c, data, err := online.Endpoint(online.ReleaseAPI, etag)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if !c </span><span class="cov0" title="0">{
                tag = fmt.Sprint(data["tag_name"])
                if tag == "" </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov0" title="0">if s, ok := data["etag"].(string); ok &amp;&amp; s != "" </span><span class="cov0" title="0">{
                        if err := CacheSet(s, tag); err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                }
        }
        <span class="cov0" title="0">if comp := Compare(meta.App.Version, tag); comp </span><span class="cov0" title="0">{
                return tag, nil
        }</span>
        <span class="cov0" title="0">return "", nil</span>
}

// CacheGet reads and returns the locally cached GitHub API.
func CacheGet() Cache <span class="cov0" title="0">{
        name, err := home().DataPath(cacheFile)
        if err != nil </span><span class="cov0" title="0">{
                logs.Sprint(err)
                return Cache{}
        }</span>
        <span class="cov0" title="0">if _, err = os.Stat(name); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return Cache{}
        }</span>
        <span class="cov0" title="0">in, err := os.ReadFile(name)
        if err != nil </span><span class="cov0" title="0">{
                logs.Sprint(err)
        }</span>
        <span class="cov0" title="0">var out Cache
        if err := yaml.Unmarshal(in, &amp;out); err != nil </span><span class="cov0" title="0">{
                logs.Sprint(err)
        }</span>
        // if either value is missing, delete the broken cache
        <span class="cov0" title="0">if out.Etag == "" || out.Version == "" </span><span class="cov0" title="0">{
                err = os.Remove(name)
                logs.Sprint(err)
                return Cache{}
        }</span>
        <span class="cov0" title="0">return out</span>
}

// CacheSet saves the Github API, ETag HTTP header and release version.
func CacheSet(etag, version string) error <span class="cov8" title="1">{
        if etag == "" || version == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">cache := Cache{
                Etag:    etag,
                Version: version,
        }
        out, err := yaml.Marshal(&amp;cache)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %w", err, ErrCacheYaml)
        }</span>
        <span class="cov8" title="1">name, err := home().DataPath(cacheFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%q: %w", cacheFile, ErrCacheData)
        }</span>
        <span class="cov8" title="1">if _, _, err := fsys.Write(name, out...); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %w", err, ErrCacheSave)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Compare reports whether the release version of this program
// matches the latest version hosted on GitHub.
func Compare(current, fetched string) bool <span class="cov8" title="1">{
        cur := meta.Semantic(current)
        if !cur.Valid() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">f := meta.Semantic(fetched)
        if !f.Valid() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if cur.Major &lt; f.Major </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if cur.Minor &lt; f.Minor </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if cur.Patch &lt; f.Patch </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// home is the user's home directory.
func home() *gap.Scope <span class="cov8" title="1">{
        return gap.NewScope(gap.User, meta.Dir)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package version provides the stdout template for the version flag.
package version

import (
        "fmt"
        "io"
        "log"
        "os"
        "runtime"
        "strings"
        "text/tabwriter"
        "time"

        "github.com/bengarrett/retrotxtgo/cmd/update"
        "github.com/bengarrett/retrotxtgo/meta"
        "github.com/gookit/color"
        "github.com/mattn/go-isatty"
        "golang.org/x/term"
)

const (
        TabWidth = 8 // Width of tab characters.
)

// Template writes the application version, copyright and build variables.
func Template(wr io.Writer) error <span class="cov8" title="1">{
        if wr == nil </span><span class="cov0" title="0">{
                wr = io.Discard
        }</span>
        <span class="cov8" title="1">const c = "\u00A9"
        exe, err := Self()
        if err != nil </span><span class="cov0" title="0">{
                exe = err.Error()
        }</span>
        <span class="cov8" title="1">tag, err := update.Check()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">appDate := ""
        if meta.App.Date != meta.Placeholder </span><span class="cov8" title="1">{
                appDate = fmt.Sprintf(" (%s)", meta.App.Date)
        }</span>
        <span class="cov8" title="1">w := tabwriter.NewWriter(wr, 0, TabWidth, 0, '\t', 0)
        fmt.Fprintf(w, "%s %s\n", meta.Name, meta.String())
        fmt.Fprintf(w, "%s %s Ben Garrett\n", meta.Copyright, c)
        fmt.Fprintln(w, color.Primary.Sprint(meta.URL))
        fmt.Fprintf(w, "\n%s\t%s %s%s\n", color.Secondary.Sprint("build:"), runtime.Compiler, meta.App.BuiltBy, appDate)
        fmt.Fprintf(w, "%s\t%s/%s\n", color.Secondary.Sprint("platform:"), runtime.GOOS, runtime.GOARCH)
        fmt.Fprintf(w, "%s\t%s\n", color.Secondary.Sprint("terminal:"), Terminal())
        fmt.Fprintf(w, "%s\t%s\n", color.Secondary.Sprint("go:"), strings.Replace(runtime.Version(), "go", "v", 1))
        fmt.Fprintf(w, "%s\t%s\n", color.Secondary.Sprint("path:"), exe)
        if tag != "" </span><span class="cov0" title="0">{
                fmt.Fprintln(w)
                update.Notice(w, meta.App.Version, tag)
                fmt.Fprintln(w)
        }</span>
        <span class="cov8" title="1">return w.Flush()</span>
}

// Self returns the path to the executable (this) program.
func Self() (string, error) <span class="cov8" title="1">{
        exe, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("self error: %w", err)
        }</span>
        <span class="cov8" title="1">return exe, nil</span>
}

// Terminal attempts to determine the host shell environment.
func Terminal() string <span class="cov8" title="1">{
        const win = "windows"
        unknown := func() string </span><span class="cov8" title="1">{
                if runtime.GOOS == win </span><span class="cov0" title="0">{
                        return "PowerShell"
                }</span>
                <span class="cov8" title="1">return "unknown"</span>
        }

        <span class="cov8" title="1">oldState, err := term.MakeRaw(int(os.Stdin.Fd()))
        if err != nil </span><span class="cov8" title="1">{
                return unknown()
        }</span>
        <span class="cov0" title="0">defer restoreTerm(oldState)
        w, h, err := term.GetSize(int(os.Stdin.Fd()))
        // code source: https://gist.github.com/mattn/00cf5b7e38f4cceaf7077f527479870c
        if os.Getenv("WT_SESSION") != "" </span><span class="cov0" title="0">{
                const s = "Windows Terminal"
                if err != nil </span><span class="cov0" title="0">{
                        return s
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%s (%dx%d)", s, w, h)</span>
        }
        <span class="cov0" title="0">if isatty.IsCygwinTerminal(os.Stdout.Fd()) </span><span class="cov0" title="0">{
                const s = "Cygwin"
                if err != nil </span><span class="cov0" title="0">{
                        return s
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("%s (%dx%d)", s, w, h)</span>
        }
        <span class="cov0" title="0">_, err = os.Stdout.Write([]byte("\x1b[c"))
        if err != nil </span><span class="cov0" title="0">{
                return unknown()
        }</span>
        <span class="cov0" title="0">defer os.Stdout.SetReadDeadline(time.Time{})
        const timeout = 10 * time.Millisecond
        time.Sleep(timeout)

        var b [100]byte
        n, err := os.Stdout.Read(b[:])
        if err != nil </span><span class="cov0" title="0">{
                return unknown()
        }</span>
        <span class="cov0" title="0">if n &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf("VT100 compatible (%dx%d)", w, h)
        }</span>
        <span class="cov0" title="0">return unknown()</span>
}

func restoreTerm(oldState *term.State) <span class="cov0" title="0">{
        if err := term.Restore(int(os.Stdin.Fd()), oldState); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package cmd

import (
        "log"
        "strings"

        "github.com/bengarrett/retrotxtgo/cmd/example"
        "github.com/bengarrett/retrotxtgo/cmd/internal/dump"
        "github.com/bengarrett/retrotxtgo/cmd/internal/flag"
        "github.com/bengarrett/retrotxtgo/cmd/internal/view"
        "github.com/spf13/cobra"
)

var viewLong = `Print a text file to the terminal using standard output.

Any texts and documents encoded in UTF-8 or that only use the common 
characters found in the 7-bit (128 characters) ASCII set are printed 
to the terminal as is. However, many old texts and documents are
encoded with legacy 8-bit (256 characters) code pages that first get 
converted to UTF-8 before being printed to the terminal.

For the legacy 8-bit texts, the input encoding will be assumed to be 
Code Page 437 otherwise called OEM-US. But you can change this using
the --input flag.

Common Code Page documents for English texts are:
  Code Page 437 (OEM-US)
  Code Page 850 (OEM Multilingual Latin 1)
  Code Page 858 (OEM Multilingual Latin 1 with the  symbol)
  ISO 8859-1 (Latin 1 commonly found on the web in the 2000s)
  Windows 1252 (Used in consumer Windows of the 1990s)

Otherwise the flags are optional and can be generally ignored 
for most use cases.`

func ViewCommand() *cobra.Command <span class="cov8" title="1">{
        s := "Print text files to the terminal using standard output"
        l := viewLong
        expl := strings.Builder{}
        example.View.String(&amp;expl)
        return &amp;cobra.Command{
                Use:     "view " + example.Filenames,
                Aliases: []string{"v"},
                GroupID: IDfile,
                Short:   s,
                Long:    l,
                Example: expl.String(),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return view.Run(cmd.OutOrStdout(), cmd, args...)
                }</span>,
        }
}

func DumpCommand() *cobra.Command <span class="cov8" title="1">{
        s := "Dump the hex data of files to the terminal"
        l := "Dump the hex data of files to the terminal."
        expl := strings.Builder{}
        example.Dump.String(&amp;expl)
        return &amp;cobra.Command{
                Use:     "dump " + example.Filenames,
                Aliases: []string{"d"},
                GroupID: IDfile,
                Short:   s,
                Long:    l,
                Example: expl.String(),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return dump.Run(cmd.OutOrStdout(), cmd, args...)
                }</span>,
        }
}

func ViewInit() *cobra.Command <span class="cov8" title="1">{
        vc := ViewCommand()
        f := flag.View()
        flag.Encode(&amp;f.Input, vc)
        flag.Controls(&amp;f.Controls, vc)
        flag.SwapChars(&amp;f.Swap, vc)
        if err := flag.OG(&amp;f.Original, vc); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">flag.Width(&amp;f.Width, vc)
        vc.Flags().SortFlags = false
        return vc</span>
}

func init() <span class="cov8" title="1">{
        Cmd.AddCommand(DumpCommand(), ViewInit())
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package convert extends the interface for the character encodings
// that transform text to and from Unicode UTF-8.
package convert

import (
        "bytes"
        "errors"
        "fmt"
        "log"
        "math"
        "os"
        "regexp"
        "strings"
        "unicode/utf8"

        "github.com/bengarrett/retrotxtgo/byter"
        "github.com/bengarrett/retrotxtgo/fsys"
        "github.com/bengarrett/retrotxtgo/logs"
        "github.com/bengarrett/retrotxtgo/term"
        "golang.org/x/text/encoding"
        "golang.org/x/text/encoding/japanese"
        "golang.org/x/text/encoding/unicode"
        "golang.org/x/text/encoding/unicode/utf32"
        "golang.org/x/text/transform"
)

var (
        ErrANSI   = errors.New("ansi controls must be chained to c.swap")
        ErrBytes  = errors.New("cannot transform an empty byte slice")
        ErrEncode = errors.New("no input encoding provided")
        ErrName   = errors.New("unknown or unsupported code page name or alias")
        ErrOutput = errors.New("nothing to output")
        ErrWidth  = errors.New("cannot find the number columns from using line break")
        ErrWrap   = errors.New("wrap width must be chained to c.swap")
)

// Convert 8-bit code page text encodings or Unicode byte array text to UTF-8 runes.
type Convert struct {
        Args  Flag // Args are the cmd supplied flag arguments.
        Input struct {
                Encoding  encoding.Encoding // Encoding are the encoding of the input text.
                Input     []byte            // Bytes are the input text as bytes.
                Ignore    []rune            // Ignore these runes.
                LineBreak [2]rune           // Line break controls used by the text.
                UseBreaks bool              // UseBreaks uses the line break controls as new lines.
                Table     bool              // Table flags this text as a code page table.
        }
        Output []rune // Output are the transformed UTF-8 runes.
}

// Flag are the user supplied values.
type Flag struct {
        Controls  []string // Always use these control codes.
        SwapChars []string // Swap out these characters with common alternatives.
        MaxWidth  int      // Maximum text width per-line.
}

// ANSI transforms legacy encoded ANSI into modern UTF-8 text.
// It displays ASCII control codes as characters.
// It obeys the DOS end of file marker.
func (c *Convert) ANSI(b ...byte) ([]rune, error) <span class="cov8" title="1">{
        c.Input.UseBreaks = true
        c.Args.SwapChars = nil
        c.Input.Input = byter.TrimEOF(b)
        if err := c.SkipCode().Transform(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dump transform failed: %w", err)
        }</span>
        <span class="cov8" title="1">c, err := c.Swap()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">c.ANSIControls().wrapWidth(c.Args.MaxWidth)
        return c.Output, nil</span>
}

// Chars transforms legacy encoded characters and text control codes into UTF-8 characters.
// It displays both ASCII and ANSI control codes as characters.
// It ignores the DOS end of file marker.
func (c *Convert) Chars(b ...byte) ([]rune, error) <span class="cov8" title="1">{
        c.Input.Table = true
        c.Input.Input = b
        if err := c.Transform(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("chars transform failed: %w", err)
        }</span>
        <span class="cov8" title="1">c, err := c.Swap()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">c.wrapWidth(c.Args.MaxWidth)
        return c.Output, nil</span>
}

// Dump transforms legacy encoded text or ANSI into modern UTF-8 text.
// It obeys common ASCII control codes.
// It ignores the DOS end of file marker.
func (c *Convert) Dump(b ...byte) ([]rune, error) <span class="cov8" title="1">{
        c.Input.UseBreaks = true
        c.Input.Input = b
        if err := c.SkipCode().Transform(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dump transform failed: %w", err)
        }</span>
        <span class="cov8" title="1">c, err := c.Swap()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">c.ANSIControls().wrapWidth(c.Args.MaxWidth)
        return c.Output, nil</span>
}

// Text transforms legacy encoded text or ANSI into modern UTF-8 text.
// It obeys common ASCII control codes.
// It obeys the DOS end of file marker.
func (c *Convert) Text(b ...byte) ([]rune, error) <span class="cov8" title="1">{
        c.Input.UseBreaks = true
        c.Input.Input = byter.TrimEOF(b)
        if err := c.SkipCode().Transform(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("text transform failed: %w", err)
        }</span>
        <span class="cov8" title="1">c, err := c.Swap()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">c.ANSIControls().wrapWidth(c.Args.MaxWidth)
        return c.Output, nil</span>
}

// Transform byte data from named character map encoded text into UTF-8.
func (c *Convert) Transform() error <span class="cov8" title="1">{
        if c.Input.Encoding == nil </span><span class="cov0" title="0">{
                return ErrEncode
        }</span>
        <span class="cov8" title="1">if len(c.Input.Input) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        // transform unicode encodings
        <span class="cov8" title="1">if r, err := unicodeDecoder(c.Input.Encoding, c.Input.Input...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> if len(r) &gt; 0 </span><span class="cov8" title="1">{
                c.Output = r
                return nil
        }</span>
        // use the input bytes if they are already valid UTF-8 runes
        <span class="cov8" title="1">if utf8.Valid(c.Input.Input) </span><span class="cov8" title="1">{
                c.Output = bytes.Runes(c.Input.Input)
                return nil
        }</span>
        // transform the input bytes into UTF-8 runes
        <span class="cov8" title="1">c.FixJISTable()
        b := &amp;bytes.Buffer{}
        t := transform.NewWriter(b, c.Input.Encoding.NewDecoder())
        defer t.Close()
        if _, err := t.Write(c.Input.Input); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">c.Output = bytes.Runes(b.Bytes())
        return nil</span>
}

// FixJISTable blanks invalid ShiftJIS characters while printing 8-bit tables.
func (c *Convert) FixJISTable() <span class="cov8" title="1">{
        if !c.Input.Table </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">input := c.Input.Encoding
        if input != japanese.ShiftJIS </span><span class="cov8" title="1">{
                return
        }</span>
        // this is only for the table command,
        // it will break normal shift-jis encode text
        <span class="cov8" title="1">const agrave, control, nobreak = 0xe0, 0x7f, 0xa0
        for i, b := range c.Input.Input </span><span class="cov8" title="1">{
                switch </span>{
                case b &gt; control &amp;&amp; b &lt;= nobreak,
                        b &gt;= agrave:<span class="cov8" title="1">
                        c.Input.Input[i] = SP</span>
                }
        }
}

// decode transforms encoded bytes into UTF-8 runes.
func decode(e encoding.Encoding, b ...byte) ([]rune, error) <span class="cov8" title="1">{
        p, err := e.NewDecoder().Bytes(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return bytes.Runes(p), nil</span>
}

// unicodeDecoder transforms UTF-8, UTF-16 or UTF-32 bytes into UTF-8 runes.
func unicodeDecoder(e encoding.Encoding, b ...byte) ([]rune, error) <span class="cov8" title="1">{
        var (
                u16be  = unicode.UTF16(unicode.BigEndian, unicode.IgnoreBOM)
                u16beB = unicode.UTF16(unicode.BigEndian, unicode.ExpectBOM)
                u16le  = unicode.UTF16(unicode.LittleEndian, unicode.IgnoreBOM)
                u16leB = unicode.UTF16(unicode.LittleEndian, unicode.ExpectBOM)
                u32be  = utf32.UTF32(utf32.LittleEndian, utf32.IgnoreBOM)
                u32beB = utf32.UTF32(utf32.BigEndian, utf32.UseBOM)
                u32le  = utf32.UTF32(utf32.LittleEndian, utf32.IgnoreBOM)
                u32leB = utf32.UTF32(utf32.LittleEndian, utf32.UseBOM)
        )
        switch e </span>{
        case unicode.UTF8, unicode.UTF8BOM:<span class="cov8" title="1">
                return bytes.Runes(b), nil</span>
        case u16be:<span class="cov8" title="1">
                return decode(u16be, b...)</span>
        case u16le:<span class="cov8" title="1">
                return decode(u16le, b...)</span>
        case u16beB:<span class="cov0" title="0">
                return decode(u16beB, b...)</span>
        case u16leB:<span class="cov0" title="0">
                return decode(u16leB, b...)</span>
        case u32be:<span class="cov0" title="0">
                return decode(u32be, b...)</span>
        case u32beB:<span class="cov0" title="0">
                return decode(u32beB, b...)</span>
        case u32le:<span class="cov0" title="0">
                return decode(u32le, b...)</span>
        case u32leB:<span class="cov0" title="0">
                return decode(u32leB, b...)</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

// replaceNL replaces newlines with single spaces.
func replaceNL(r ...rune) []rune <span class="cov8" title="1">{
        re := regexp.MustCompile(`\r?\n`)
        const space = " "
        s := re.ReplaceAllString(string(r), space)
        return []rune(s)
}</span>

// SkipCode marks control characters to be ignored.
// It needs to be applied before Convert.transform().
func (c *Convert) SkipCode() *Convert <span class="cov8" title="1">{
        unknown := []string{}
        for _, v := range c.Args.Controls </span><span class="cov8" title="1">{
                v = strings.TrimSpace(v)
                switch strings.ToLower(v) </span>{
                case "eof", "=":<span class="cov0" title="0">
                        continue</span>
                case "tab", "ht", "t":<span class="cov0" title="0">
                        c.ignore(HT)</span>
                case "bell", "bel", "b":<span class="cov0" title="0">
                        c.ignore(BEL)</span>
                case "cr", "c":<span class="cov0" title="0">
                        c.ignore(CR)</span>
                case "lf", "l":<span class="cov0" title="0">
                        c.ignore(LF)</span>
                case "backspace", "bs":<span class="cov8" title="1">
                        c.ignore(BS)</span>
                case "del", "d":<span class="cov8" title="1">
                        c.ignore(DEL)</span>
                case "esc", "e":<span class="cov0" title="0">
                        c.ignore(ESC)</span>
                case "formfeed", "ff", "f":<span class="cov0" title="0">
                        c.ignore(FF)</span>
                case "vtab", "vt", "v":<span class="cov8" title="1">
                        c.ignore(VT)</span>
                default:<span class="cov8" title="1">
                        unknown = append(unknown, v)</span>
                }
        }
        <span class="cov8" title="1">if len(unknown) &gt; 1 </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, term.Inform(),
                        "unsupported control values:", strings.Join(unknown, ","))
        }</span>
        <span class="cov8" title="1">return c</span>
}

// ignore adds the rune to an ignore runes list.
func (c *Convert) ignore(r rune) <span class="cov8" title="1">{
        c.Input.Ignore = append(c.Input.Ignore, r)
}</span>

// wrapWidth enforces a row length by inserting newline characters.
// Any tab characters are replaced with three spaces.
func (c *Convert) wrapWidth(maximum int) <span class="cov8" title="1">{
        if c == nil || maximum &lt; 1 </span><span class="cov8" title="1">{
                return
        }</span>
        // remove newlines
        <span class="cov8" title="1">c.Output = replaceNL(c.Output...)
        // replace tabs with three spaces
        s := string(c.Output)
        const threeSpaces = "   "
        s = strings.ReplaceAll(s, "\t", threeSpaces)
        c.Output = []rune(s)
        cnt := len(c.Output)
        if cnt == 0 </span><span class="cov0" title="0">{
                log.Fatal(ErrWrap)
        }</span>
        <span class="cov8" title="1">r := strings.NewReader(string(c.Output))
        cols, err := fsys.Columns(r, c.Input.LineBreak)
        if err != nil </span><span class="cov0" title="0">{
                logs.FatalS(ErrWidth, err, fmt.Sprint(c.Input.LineBreak))
        }</span>
        <span class="cov8" title="1">if cols &lt;= maximum </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">limit := math.Ceil(float64(cnt) / float64(maximum))
        b := &amp;bytes.Buffer{}
        for f := float64(1); f &lt;= limit; f++ </span><span class="cov8" title="1">{
                switch f </span>{
                case 1:<span class="cov8" title="1">
                        fmt.Fprintf(b, "%s\n", string(c.Output[0:maximum]))</span>
                default:<span class="cov8" title="1">
                        i := int(f)
                        x, y := (i-1)*maximum, i*maximum
                        if y &gt;= cnt </span><span class="cov8" title="1">{
                                fmt.Fprintf(b, "%s\n", string(c.Output[x:cnt]))
                                continue</span>
                        }
                        <span class="cov8" title="1">fmt.Fprintf(b, "%s\n", string(c.Output[x:y]))</span>
                }
        }
        <span class="cov8" title="1">c.Output = []rune(b.String())</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package convert

import (
        "bytes"
        "fmt"
        "log"
        "os"
        "strings"
        "unicode/utf8"

        "github.com/bengarrett/retrotxtgo/fsys"
        "github.com/bengarrett/retrotxtgo/term"
        "github.com/bengarrett/retrotxtgo/xud"
        "golang.org/x/text/encoding"
        "golang.org/x/text/encoding/charmap"
        "golang.org/x/text/encoding/htmlindex"
        "golang.org/x/text/encoding/ianaindex"
        "golang.org/x/text/encoding/japanese"
        "golang.org/x/text/encoding/traditionalchinese"
        "golang.org/x/text/encoding/unicode"
        "golang.org/x/text/encoding/unicode/utf32"
        "golang.org/x/text/runes"
        "golang.org/x/text/transform"
)

// The common ASCII and Unicode control decimal values.
const (
        // NUL Null control code.
        NUL = iota
        // SOH Start of heading.
        SOH
        // STX Start of text.
        STX
        // ETX End of text.
        ETX
        // EOT End of transmission.
        EOT
        // ENQ Enquiry.
        ENQ
        // ACK Acknowledge.
        ACK
        // BEL Bell or alert.
        BEL
        // BS Backspace.
        BS
        // HT Horizontal tabulation.
        HT
        // LF Line feed.
        LF
        // VT Vertical tabulation.
        VT
        // FF Form feed.
        FF
        // CR Carriage return.
        CR
        // SO Shift out.
        SO
        // SI Shift in.
        SI
        // DLE Data Link Escape.
        DLE
        // DC1 Device control one.
        DC1
        // DC2 Device control two.
        DC2
        // DC3 Device control three.
        DC3
        // DC4 Device control four.
        DC4
        // NAK Negative acknowledge.
        NAK
        // SYN Synchronous idle.
        SYN
        // ETB End of transmission block.
        ETB
        // CAN Cancel.
        CAN
        // EM End of medium.
        EM
        // SUB Substitute.
        SUB
        // ESC Escape.
        ESC
        // FS File separator.
        FS
        // GS Group separator.
        GS
        // RS Record separator.
        RS
        // US Unit separator.
        US
        // SP Space.
        SP
)

// Special ASCII and Unicode character codes and symbols.
const (
        // LeftSquareBracket [.
        LeftSquareBracket = 91
        // VerticalBar |.
        VerticalBar = 124
        // DEL Delete.
        DEL = 127
        // Dash Hyphen -.
        Dash = 150
        // Nbsp Non-breaking space.
        Nbsp = 160
        // InvertedExclamation .
        InvertedExclamation = 161
        // Cent .
        Cent = 162
        // BrokenBar .
        BrokenBar = 166
        // Negation .
        Negation = 172
        // PlusMinus .
        PlusMinus = 177
        // LightVertical light vertical .
        LightVertical = 179
        // SquareRoot Square root .
        SquareRoot = 251
        // NBSP Non-breaking space.
        NBSP = 255
        // Delta .
        Delta = 916
        // LeftwardsArrow .
        LeftwardsArrow = 8592
        // SquareRootU Unicode square root .
        SquareRootU = 8730
        // House .
        House = 8962
        // IntegralExtension .
        IntegralExtension = 9134
        // SymbolNUL .
        SymbolNUL = 9216
        // SymbolESC .
        SymbolESC = 9243
        // SymbolDEL .
        SymbolDEL = 9249
        // LightVerticalU Box drawing light vertical .
        LightVerticalU = 9474
        // CheckMark .
        CheckMark = 10003
        // Replacement character .
        Replacement = 65533
        // Open Box .
        OpenBox = 9251
)

const (
        Row8  = 128 // the first cell after the end of a 7-bit row.
        row8f = 143
        row9  = 144
        row9f = 159
        rowA  = 160
        rowE  = 224
        cp037 = "IBM037"
        cp858 = "IBM00858"
        ibm   = "ibm"
        msdos = "msdos"
        u32   = "UTF-32"
        u32be = "UTF-32BE"
        u32le = "UTF-32LE"
        win   = "windows"
)

// Encoder returns the named character set encoder.
func Encoder(name string) (encoding.Encoding, error) <span class="cov8" title="1">{
        // use charmap string
        for _, c := range charmap.All </span><span class="cov8" title="1">{
                if fmt.Sprint(c) == name </span><span class="cov8" title="1">{
                        return c, nil
                }</span>
        }
        // use iana names or alias
        <span class="cov8" title="1">if e, err := ianaindex.IANA.Encoding(name); err == nil &amp;&amp; e != nil </span><span class="cov8" title="1">{
                return e, nil
        }</span>
        // use html index name (only used with HTML compatible encodings)
        // https://encoding.spec.whatwg.org/#names-and-labels
        <span class="cov8" title="1">if e, err := htmlindex.Get(name); err == nil &amp;&amp; e != nil </span><span class="cov8" title="1">{
                return e, nil
        }</span>
        <span class="cov8" title="1">s := Shorten(name)
        a := EncodeAlias(s)
        if a == xud.Name(xud.XUserDefinedISO11) </span><span class="cov0" title="0">{
                // ISO-8859-11 uses the same characters as Windows 847
                // except for 9 characters in rows 8 and 9.
                // https://en.wikipedia.org/wiki/ISO/IEC_8859-11#Code_page_874_(IBM)_/_9066
                return xud.XUserDefinedISO11, nil
        }</span>
        <span class="cov8" title="1">if e := EncodeUTF32(a); e != nil </span><span class="cov0" title="0">{
                return e, nil
        }</span>
        <span class="cov8" title="1">e, err := ianaindex.IANA.Encoding(s)
        if err != nil </span><span class="cov8" title="1">{
                e, err = ianaindex.IANA.Encoding(a)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                e, err = ianaindex.IANA.Encoding(EncodeAlias(name))
        }</span>
        <span class="cov8" title="1">if err != nil || e == nil </span><span class="cov8" title="1">{
                if a == "" </span><span class="cov8" title="1">{
                        return e, fmt.Errorf("%q: %w", name, ErrName)
                }</span>
                <span class="cov0" title="0">return e, fmt.Errorf("name %q or alias %q: %w", name, a, ErrName)</span>
        }
        <span class="cov8" title="1">return e, nil</span>
}

// EncodeUTF32 initializes common UTF-32 encodings.
func EncodeUTF32(name string) encoding.Encoding <span class="cov8" title="1">{
        // UTF-32... doesn't return a match in ianaindex.IANA
        switch strings.ToUpper(name) </span>{
        case u32:<span class="cov8" title="1">
                return utf32.UTF32(utf32.LittleEndian, utf32.UseBOM)</span>
        case u32be:<span class="cov0" title="0">
                return utf32.UTF32(utf32.BigEndian, utf32.IgnoreBOM)</span>
        case u32le:<span class="cov0" title="0">
                return utf32.UTF32(utf32.LittleEndian, utf32.IgnoreBOM)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Humanize the encoding by using an shorter, less formal name.
func Humanize(name string) string <span class="cov8" title="1">{
        if _, err := Encoder(name); err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return EncodeAlias(Shorten(name))</span>
}

// Shorten the name to a custom name, a common name or an alias.
func Shorten(name string) string <span class="cov8" title="1">{
        n, l := strings.ToLower(name), len(name)
        switch </span>{
        case l &gt; 3 &amp;&amp; n[:3] == "cp-":<span class="cov8" title="1">
                return n[3:]</span>
        case l &gt; 2 &amp;&amp; n[:2] == "cp":<span class="cov8" title="1">
                return n[2:]</span>
        case l &gt; 14 &amp;&amp; n[:14] == "ibm code page ":<span class="cov0" title="0">
                return ibm + n[14:]</span>
        case l &gt; 4 &amp;&amp; n[:4] == "ibm-":<span class="cov8" title="1">
                return n[4:]</span>
        case l &gt; 3 &amp;&amp; n[:3] == ibm:<span class="cov0" title="0">
                return n[3:]</span>
        case l &gt; 4 &amp;&amp; n[:4] == "oem-":<span class="cov8" title="1">
                return n[4:]</span>
        case n == "windows code page 858":<span class="cov0" title="0">
                return cp858</span>
        case l &gt; 8 &amp;&amp; n[:8] == "windows-":<span class="cov8" title="1">
                return n[8:]</span>
        case l &gt; 7 &amp;&amp; n[:7] == win:<span class="cov0" title="0">
                return n[7:]</span>
        case l &gt; 7 &amp;&amp; n[:7] == "iso8859":<span class="cov0" title="0">
                return "iso-8859-" + n[7:]</span>
        case l &gt; 9 &amp;&amp; n[:9] == "iso 8859-":<span class="cov0" title="0">
                return "iso-8859-" + n[9:]</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// EncodeAlias returns a valid IANA index encoding name from a shorten name or alias.
func EncodeAlias(name string) string <span class="cov8" title="1">{
        // list of valid tables
        // https://github.com/golang/text/blob/v0.3.2/encoding/charmap/maketables.go
        // a switch is used instead of a map to avoid typos with duplicate values
        if s := encodingIBM(name); s != "" </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">if s := encodingMisc(name); s != "" </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">if s := encodingWin(name); s != "" </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">if s := encodingISO(name); s != "" </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">if s := encodingUnicode(name); s != "" </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// encodingIBM returns a valid IANA index encoding name for IBM code pages using a custom alias.
func encodingIBM(name string) string <span class="cov8" title="1">{
        switch name </span>{
        case "37", "037":<span class="cov8" title="1">
                return cp037</span>
        case "437", "dos", "ibmpc", msdos, "us", "pc-8", "latin-us":<span class="cov8" title="1">
                return "IBM437"</span>
        case "850", "latini":<span class="cov8" title="1">
                return "IBM850"</span>
        case "852", "latinii":<span class="cov8" title="1">
                return "IBM852"</span>
        case "855":<span class="cov8" title="1">
                return "IBM855"</span>
        case "858":<span class="cov8" title="1">
                return cp858</span>
        case "860":<span class="cov8" title="1">
                return "IBM860"</span>
        case "862":<span class="cov8" title="1">
                return "IBM862"</span>
        case "863":<span class="cov8" title="1">
                return "IBM863"</span>
        case "865":<span class="cov8" title="1">
                return "IBM865"</span>
        case "866":<span class="cov8" title="1">
                return "IBM866"</span>
        case "1047":<span class="cov8" title="1">
                return "IBM1047"</span>
        case "1140", "ibm1140":<span class="cov8" title="1">
                return "IBM01140"</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// encodingMisc returns a valid IANA index encoding name using a custom alias.
func encodingMisc(name string) string <span class="cov8" title="1">{
        switch name </span>{
        case "878", "20866", "koi8r":<span class="cov8" title="1">
                return "KOI8-R"</span>
        case "1168", "21866", "koi8u":<span class="cov8" title="1">
                return "KOI8-U"</span>
        case "10000", "macroman", "mac-roman", "mac os roman":<span class="cov8" title="1">
                return "Macintosh"</span>
        case "shift jis", "shiftjis":<span class="cov0" title="0">
                return "shift_jis"</span>
        case "big-5":<span class="cov0" title="0">
                return "Big5"</span>
        case "ebcdic", ibm:<span class="cov0" title="0">
                return cp037</span>
        case "iso88598e", "iso88598i", "iso88596e", "iso88596i":<span class="cov0" title="0">
                l := len(name)
                return fmt.Sprintf("ISO-8859-%v-%v", name[l-2:l-1], name[l-1:])</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// encodingIBM returns a valid IANA index encoding name for Microsoft code pages using a custom alias.
func encodingWin(name string) string <span class="cov8" title="1">{
        switch name </span>{
        case "874":<span class="cov8" title="1">
                return "Windows-874"</span>
        case "1250":<span class="cov8" title="1">
                return "Windows-1250"</span>
        case "1251":<span class="cov8" title="1">
                return "Windows-1251"</span>
        case "1252", "1004", "win", win:<span class="cov8" title="1">
                return "Windows-1252"</span>
        case "1253":<span class="cov8" title="1">
                return "Windows-1253"</span>
        case "1254":<span class="cov8" title="1">
                return "Windows-1254"</span>
        case "1255":<span class="cov8" title="1">
                return "Windows-1255"</span>
        case "1256":<span class="cov8" title="1">
                return "Windows-1256"</span>
        case "1257":<span class="cov8" title="1">
                return "Windows-1257"</span>
        case "1258":<span class="cov8" title="1">
                return "Windows-1258"</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// encodingIBM returns a valid IANA index encoding name for ISO code pages using a custom alias.
func encodingISO(name string) string <span class="cov8" title="1">{
        switch name </span>{
        case "5", "1124", "28595":<span class="cov8" title="1">
                return "ISO-8859-5"</span>
        case "6", "1089", "28596":<span class="cov8" title="1">
                return "ISO-8859-6"</span>
        case "7", "813", "28597":<span class="cov8" title="1">
                return "ISO-8859-7"</span>
        case "8", "916", "1125", "28598":<span class="cov8" title="1">
                return "ISO-8859-8"</span>
        case "9", "920", "28599":<span class="cov8" title="1">
                return "ISO-8859-9"</span>
        case "10", "919", "28600":<span class="cov8" title="1">
                return "ISO-8859-10"</span>
        case "11", xud.Name(xud.XUserDefinedISO11):<span class="cov8" title="1">
                return fmt.Sprint(xud.XUserDefinedISO11)</span>
        case "13", "921", "28603":<span class="cov8" title="1">
                return "ISO-8859-13"</span>
        case "14", "28604":<span class="cov8" title="1">
                return "ISO-8859-14"</span>
        case "15", "923", "28605":<span class="cov8" title="1">
                return "ISO-8859-15"</span>
        case "16", "28606", "iso885916":<span class="cov8" title="1">
                return "ISO-8859-16"</span>
        default:<span class="cov8" title="1">
                if s := encodingEurope(name); s != "" </span><span class="cov8" title="1">{
                        return s
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// encodingIBM returns a valid IANA index encoding name for Latin code pages using a custom alias.
func encodingEurope(name string) string <span class="cov8" title="1">{
        switch name </span>{
        case "1", "819", "28591":<span class="cov8" title="1">
                return "ISO-8859-1"</span>
        case "2", "1111", "28592":<span class="cov8" title="1">
                return "ISO-8859-2"</span>
        case "3", "913", "28593":<span class="cov8" title="1">
                return "ISO-8859-3"</span>
        case "4", "914", "28594":<span class="cov8" title="1">
                return "ISO-8859-4"</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// encodingIBM returns a valid IANA index encoding name for Unicode using a custom alias.
func encodingUnicode(name string) string <span class="cov8" title="1">{
        switch strings.ToLower(name) </span>{
        case "utf16":<span class="cov0" title="0">
                return "UTF-16"</span> // Go will use the byte-order-mark
        case "16be", "utf16b", "utf16be", "utf-16-be":<span class="cov0" title="0">
                return "UTF-16BE"</span>
        case "16le", "utf16l", "utf16le", "utf-16-le":<span class="cov0" title="0">
                return "UTF-16LE"</span>
        case "utf32", "utf-32":<span class="cov0" title="0">
                return u32</span> // Go will use the byte-order-mark
        case "32be", "utf32b", "utf32be", "utf-32be", "utf-32-be":<span class="cov0" title="0">
                return u32be</span>
        case "32le", "utf32l", "utf32le", "utf-32le", "utf-32-le":<span class="cov0" title="0">
                return u32le</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// Swap transforms character map and control codes into UTF-8 unicode runes.
func (c *Convert) Swap() (*Convert, error) <span class="cov8" title="1">{
        if len(c.Output) == 0 </span><span class="cov8" title="1">{
                return nil, ErrOutput
        }</span>
        <span class="cov8" title="1">c, err := c.Swaps()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if c.Input.UseBreaks </span><span class="cov8" title="1">{
                c.LineBreak()
        }</span>
        <span class="cov8" title="1">switch c.Input.Encoding </span>{
        case charmap.CodePage037, charmap.CodePage1047, charmap.CodePage1140:<span class="cov8" title="1">
                if c.Input.Table </span><span class="cov0" title="0">{
                        c.RunesEBCDIC()
                }</span>
                <span class="cov8" title="1">c.RunesControlsEBCDIC()</span>
        case charmap.CodePage437, charmap.CodePage850, charmap.CodePage852, charmap.CodePage855,
                charmap.CodePage858, charmap.CodePage860, charmap.CodePage862, charmap.CodePage863,
                charmap.CodePage865, charmap.CodePage866:<span class="cov8" title="1">
                c.RunesDOS()</span>
        case charmap.ISO8859_1, charmap.ISO8859_2, charmap.ISO8859_3, charmap.ISO8859_4, charmap.ISO8859_5,
                charmap.ISO8859_6, charmap.ISO8859_7, charmap.ISO8859_8, charmap.ISO8859_9, charmap.ISO8859_10,
                charmap.ISO8859_13, charmap.ISO8859_14, charmap.ISO8859_15, charmap.ISO8859_16,
                charmap.Windows874:<span class="cov8" title="1">
                c.RunesLatin()</span>
        case xud.XUserDefinedISO11:<span class="cov0" title="0">
                c.RunesLatin()
                c.RunesXRows()</span>
        case charmap.ISO8859_6E, charmap.ISO8859_6I, charmap.ISO8859_8E, charmap.ISO8859_8I:<span class="cov8" title="1">
                c.RunesControls()
                c.RunesLatin()</span>
        case charmap.KOI8R, charmap.KOI8U:<span class="cov8" title="1">
                c.RunesKOI8()</span>
        case charmap.Macintosh:<span class="cov8" title="1">
                c.RunesMacintosh()</span>
        case charmap.Windows1250, charmap.Windows1251, charmap.Windows1252, charmap.Windows1253,
                charmap.Windows1254, charmap.Windows1255, charmap.Windows1256, charmap.Windows1257, charmap.Windows1258:<span class="cov8" title="1">
                c.RunesControls()
                c.RunesWindows()</span>
        case japanese.ShiftJIS:<span class="cov8" title="1">
                c.RunesControls()
                c.RunesShiftJIS()</span>
        case traditionalchinese.Big5:<span class="cov0" title="0">
                c.RunesControls()</span>
        case unicode.UTF8, unicode.UTF8BOM:<span class="cov8" title="1">
                c.RunesControls()
                c.RunesUTF8()</span>
        default:<span class="cov8" title="1"></span>
        }
        <span class="cov8" title="1">return c, nil</span>
}

func (c *Convert) Swaps() (*Convert, error) <span class="cov8" title="1">{
        if len(c.Args.SwapChars) == 0 </span><span class="cov8" title="1">{
                return c, nil
        }</span>
        <span class="cov8" title="1">replacers, unknown := []rune{}, []string{}
        for _, val := range c.Args.SwapChars </span><span class="cov8" title="1">{
                nr := newReplacer(val)
                if nr == nil </span><span class="cov0" title="0">{
                        unknown = append(unknown, val)
                }</span>
                <span class="cov8" title="1">replacers = append(replacers, nr...)</span>
        }
        <span class="cov8" title="1">if len(unknown) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, term.Inform(),
                        "unsupported swap-chars values:", strings.Join(unknown, ","))
        }</span>
        <span class="cov8" title="1">replace := runes.Map(func(r rune) rune </span><span class="cov8" title="1">{
                if !replacer(r, replacers...) </span><span class="cov8" title="1">{
                        return r
                }</span>
                <span class="cov8" title="1">return Swap(r)</span>
        })
        <span class="cov8" title="1">s, _, err := transform.String(replace, string(c.Output))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">c.Output = []rune(s)
        return c, nil</span>
}

func replacer(r rune, replacers ...rune) bool <span class="cov8" title="1">{
        for _, s := range replacers </span><span class="cov8" title="1">{
                if s == r </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func newReplacer(s string) []rune <span class="cov8" title="1">{
        switch strings.ToLower(s) </span>{
        case "n", "nul", "null", "00", "0":<span class="cov8" title="1">
                return []rune{NUL, SymbolNUL}</span>
        case "b", "bar", "7c", "124":<span class="cov8" title="1">
                return []rune{VerticalBar}</span>
        case "h", "house", "home", "7f", "127":<span class="cov8" title="1">
                return []rune{DEL, House}</span>
        case "p", "pipe", "b3", "179":<span class="cov8" title="1">
                return []rune{LightVertical, LightVerticalU}</span>
        case "r", "root", "squareroot", "fb", "251":<span class="cov8" title="1">
                return []rune{SquareRoot, SquareRootU}</span>
        case "s", "space", "20", "32":<span class="cov0" title="0">
                return []rune{SP}</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func Swap(code rune) rune <span class="cov8" title="1">{
        return map[rune]rune{
                NUL:       SP,
                SymbolNUL: SP,
                // 
                VerticalBar: BrokenBar,
                // 
                DEL:   Delta,
                House: Delta,
                // 
                LightVertical:  IntegralExtension,
                LightVerticalU: IntegralExtension,
                // 
                SquareRoot:  CheckMark,
                SquareRootU: CheckMark,
                // 
                SP: OpenBox,
        }[code]
}</span>

// ANSIControls replaces out all [ and [ character matches with functional ANSI escape controls.
func (c *Convert) ANSIControls() *Convert <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if len(c.Output) == 0 </span><span class="cov0" title="0">{
                log.Fatal(ErrANSI)
        }</span>
        <span class="cov8" title="1">for i, r := range c.Output </span><span class="cov8" title="1">{
                if i+1 &gt;= len(c.Output) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if r == LeftwardsArrow &amp;&amp; c.Output[i+1] == LeftSquareBracket </span><span class="cov8" title="1">{
                        c.Output[i] = ESC // replace [
                        continue</span>
                }
                <span class="cov8" title="1">if r == SymbolESC &amp;&amp; c.Output[i+1] == LeftSquareBracket </span><span class="cov8" title="1">{
                        c.Output[i] = ESC // replace [
                }</span>
        }
        <span class="cov8" title="1">return c</span>
}

// LineBreak will try to guess the line break representation as a 2 byte value.
// A guess of Unix will return [10, 0], Windows [13, 10], otherwise a [0, 0] value is returned.
func (c *Convert) LineBreak() <span class="cov8" title="1">{
        c.Input.LineBreak = fsys.LineBreaks(true, c.Output...)
}</span>

// RunesControls switches out C0 and C1 ASCII controls with Unicode Control Picture represenations.
func (c *Convert) RunesControls() <span class="cov8" title="1">{
        if len(c.Output) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">const z = byte(Row8)
        for i := 0; i &lt; len(c.Output); i++ </span><span class="cov8" title="1">{
                r := c.Output[i]
                if c.SkipIgnore(i) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if c.skipBreak(i) </span><span class="cov0" title="0">{
                        if c.Input.LineBreak == [2]rune{CR, 0} </span><span class="cov0" title="0">{
                                c.Output[i] = LF
                        }</span>
                        <span class="cov0" title="0">i++
                        continue</span>
                }
                <span class="cov8" title="1">if r &gt;= NUL &amp;&amp; r &lt;= US </span><span class="cov8" title="1">{
                        c.Output[i] = Picture(byte(rune(z) + r))
                }</span>
        }
}

// RunesControlsEBCDIC switches out EBCDIC controls with Unicode Control Picture represenations.
func (c *Convert) RunesControlsEBCDIC() <span class="cov8" title="1">{
        if len(c.Output) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">const z = byte(Row8)
        for i := range len(c.Output) </span><span class="cov8" title="1">{
                r := c.Output[i]
                if c.SkipIgnore(i) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if r &gt;= NUL &amp;&amp; r &lt;= US </span><span class="cov8" title="1">{
                        c.Output[i] = Picture(byte(rune(z) + r))
                }</span>
        }
}

// RunesDOS switches out C0, C1 and other controls with PC/MS-DOS picture glyphs.
func (c *Convert) RunesDOS() <span class="cov8" title="1">{
        if len(c.Output) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        // ASCII C0 = row 1, C1 = row 2
        <span class="cov8" title="1">ctrls := [32]string{
                string(Picture(Row8 + byte(0))),
                "\u263A", "\u263B", "\u2665", "\u2666", "\u2663", "\u2660",
                "\u2022", "\u25D8", "\u25CB", "\u25D9", "\u2642", "\u2640",
                "\u266A", "\u266B", "\u263C", "\u25BA", "\u25C4", "\u2195",
                "\u203C", "\u00B6", "\u00A7", "\u25AC", "\u21A8", "\u2191",
                "\u2193", "\u2192", "\u2190", "\u221F", "\u2194", "\u25B2", "\u25BC",
        }
        for i := 0; i &lt; len(c.Output); i++ </span><span class="cov8" title="1">{
                r := c.Output[i]
                if c.SkipIgnore(i) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if c.skipBreak(i) </span><span class="cov8" title="1">{
                        if c.Input.LineBreak == [2]rune{13, 0} </span><span class="cov0" title="0">{
                                c.Output[i] = LF // swap CR with LF
                        }</span>
                        <span class="cov8" title="1">i++
                        continue</span>
                }
                <span class="cov8" title="1">switch </span>{
                case r &gt;= NUL &amp;&amp; r &lt;= US:<span class="cov8" title="1">
                        c.Output[i], _ = utf8.DecodeRuneInString(ctrls[r])</span> // c0, c1 controllers
                case r == DEL:<span class="cov8" title="1">
                        house := [3]byte{0xE2, 0x8C, 0x82} // 
                        c.Output[i], _ = utf8.DecodeRune(house[:])</span>
                case r == NBSP:<span class="cov0" title="0">
                        noBreakSpace := [2]byte{0xC2, 0xA0} // NBSP
                        c.Output[i], _ = utf8.DecodeRune(noBreakSpace[:])</span>
                }
        }
}

// RunesEBCDIC switches out EBCDIC IBM mainframe controls with Unicode picture represenations.
// Where no appropriate picture exists a space placeholder is used.
func (c *Convert) RunesEBCDIC() <span class="cov8" title="1">{
        if len(c.Output) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for i := range len(c.Output) </span><span class="cov8" title="1">{
                r := c.Output[i]
                if c.SkipIgnore(i) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if c.control(i, r) </span><span class="cov0" title="0">{
                        continue</span>
                }
        }
}

// Control switches out an EBCDIC IBM mainframe controls with Unicode picture representations.
// It also reports whether int character index should be skipped.
func (c *Convert) control(i int, r rune) bool <span class="cov8" title="1">{
        if i &gt; len(c.Output) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">const (
                ht  = 0x89
                del = 0xA1
                nl  = 0xA4
                bs  = 0x88
                lf  = 0x8A
                etb = 0x97
                esc = 0x9B
                enq = 0x85
                ack = 0x86
                bel = 0x87
                syn = 0x96
                eot = 0x84
                dc4 = 0x94
                nak = 0x95
                sub = 0x9A
                nel = 133
        )
        switch r </span>{
        case HT:<span class="cov8" title="1">
                c.Output[i] = Picture(ht)
                return false</span>
        case DEL:<span class="cov8" title="1">
                c.Output[i] = Picture(del)
                return false</span>
        case nel:<span class="cov0" title="0">
                if c.Input.UseBreaks </span><span class="cov0" title="0">{
                        c.Output[i] = LF // Go will automatically convert this to CRLF on Windows
                        return true
                }</span>
                <span class="cov0" title="0">c.Output[i] = Picture(nl)
                return false</span>
        case BS:<span class="cov0" title="0">
                c.Output[i] = Picture(bs)
                return false</span>
        case LF:<span class="cov0" title="0">
                c.Output[i] = Picture(lf)
                return false</span>
        case ETB:<span class="cov0" title="0">
                c.Output[i] = Picture(etb)
                return false</span>
        case ESC:<span class="cov0" title="0">
                c.Output[i] = Picture(esc)
                return false</span>
        case ENQ:<span class="cov0" title="0">
                c.Output[i] = Picture(enq)
                return false</span>
        case ACK:<span class="cov0" title="0">
                c.Output[i] = Picture(ack)
                return false</span>
        case BEL:<span class="cov8" title="1">
                c.Output[i] = Picture(bel)
                return false</span>
        case SYN:<span class="cov0" title="0">
                c.Output[i] = Picture(syn)
                return false</span>
        case Dash:<span class="cov0" title="0">
                c.Output[i] = Picture(eot)
                return false</span>
        case DC4:<span class="cov0" title="0">
                c.Output[i] = Picture(dc4)
                return false</span>
        case NAK:<span class="cov0" title="0">
                c.Output[i] = Picture(nak)
                return false</span>
        case SUB:<span class="cov0" title="0">
                c.Output[i] = Picture(sub)
                return false</span>
        default:<span class="cov8" title="1">
                c.miscCtrls(i, r)</span>
        }
        <span class="cov8" title="1">return false</span>
}

// miscCtrls switches out an EBCDIC control with Unicode Control Picture representation.
// Controls included those shared with ASCII C0+C1, NBSP and unprintables.
func (c *Convert) miscCtrls(i int, r rune) <span class="cov8" title="1">{
        switch r </span>{
        case Nbsp:<span class="cov0" title="0">
                noBreakSpace := [2]byte{0xC2, 0xA0}
                c.Output[i], _ = utf8.DecodeRune(noBreakSpace[:])</span>
        case NUL, SOH, STX, ETX, VT, FF, CR, SO, SI, DLE, DC1, DC2, DC3, CAN, EM, FS, GS, RS, US:<span class="cov8" title="1">
                // shared controls with ASCII C0+C1
                c.Output[i] = Picture(Row8 + byte(r))</span>
        case EOT, InvertedExclamation:<span class="cov8" title="1">
                // unprintable controls
                c.Output[i] = rune(SP)</span>
        case Cent, Negation, PlusMinus:<span class="cov0" title="0">
                return</span>
        default:<span class="cov8" title="1">
                c.outOfRange(i, r)</span>
        }
}

// outOfRange replaces EBCDIC runes that are out of range of
// valid 8-bit ASCII tables with a space placeholder.
func (c *Convert) outOfRange(i int, r rune) <span class="cov8" title="1">{
        const skipA, skipB, skipC, skipD = 0xA0, 0xBF, 0xC0, 0xFF
        switch </span>{
        case
                r &gt;= skipA &amp;&amp; r &lt;= skipB,
                r &gt;= skipC &amp;&amp; r &lt;= skipD,
                r &gt;= Row8 &amp;&amp; r &lt;= row8f,
                r &gt;= row9 &amp;&amp; r &lt;= row9f:<span class="cov8" title="1">
                c.Output[i] = rune(SP)</span>
        }
}

// RunesKOI8 blanks out unused C0, C1 and other controls spaces for Russian sets.
func (c *Convert) RunesKOI8() <span class="cov8" title="1">{
        if len(c.Output) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(c.Output); i++ </span><span class="cov8" title="1">{
                r := c.Output[i]
                if c.skipBreak(i) </span><span class="cov0" title="0">{
                        i++
                        continue</span>
                }
                <span class="cov8" title="1">switch </span>{
                case r &gt;= NUL &amp;&amp; r &lt;= US:<span class="cov8" title="1">
                        c.Output[i] = rune(SP)</span>
                case r == DEL:<span class="cov0" title="0">
                        c.Output[i] = rune(SP)</span>
                case r == Replacement:<span class="cov0" title="0">
                        c.Output[i] = rune(SP)</span>
                }
        }
}

// RunesLatin blanks out unused C0, C1 and other controls spaces for ISO Latin sets.
func (c *Convert) RunesLatin() <span class="cov8" title="1">{
        if len(c.Output) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(c.Output); i++ </span><span class="cov8" title="1">{
                r := c.Output[i]
                if c.skipBreak(i) </span><span class="cov0" title="0">{
                        i++
                        continue</span>
                }
                <span class="cov8" title="1">switch </span>{
                case r &gt;= NUL &amp;&amp; r &lt;= US:<span class="cov8" title="1">
                        c.Output[i] = rune(SP)</span>
                case r &gt;= DEL &amp;&amp; r &lt;= row9f:<span class="cov8" title="1">
                        c.Output[i] = rune(SP)</span>
                case r == Replacement:<span class="cov0" title="0">
                        c.Output[i] = rune(SP)</span>
                }
        }
}

// RunesXRows blanks out rows 8x and 9x with spaces.
func (c *Convert) RunesXRows() <span class="cov0" title="0">{
        if len(c.Output) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for i := range len(c.Output) </span><span class="cov0" title="0">{
                switch </span>{
                case
                        i &gt;= Row8 &amp;&amp; i &lt;= row8f,
                        i &gt;= row9 &amp;&amp; i &lt;= row9f:<span class="cov0" title="0">
                        c.Output[i] = rune(SP)</span>
                }
        }
}

// RunesMacintosh replaces specific Mac OS Roman characters with Unicode picture represenations.
func (c *Convert) RunesMacintosh() <span class="cov8" title="1">{
        const (
                command = iota + 17 // 
                shift               // 
                option              // 
                control             // 

                z = byte(Row8)
        )
        for i := 0; i &lt; len(c.Output); i++ </span><span class="cov8" title="1">{
                r := c.Output[i]
                if c.skipBreak(i) </span><span class="cov0" title="0">{
                        i++
                        continue</span>
                }
                <span class="cov8" title="1">switch r </span>{
                case command:<span class="cov8" title="1">
                        commandR := [3]byte{0xE2, 0x8C, 0x98}
                        c.Output[i], _ = utf8.DecodeRune(commandR[:])</span>
                case shift:<span class="cov8" title="1">
                        shiftR := [3]byte{0xE2, 0x87, 0xA7}
                        c.Output[i], _ = utf8.DecodeRune(shiftR[:])</span>
                case option:<span class="cov0" title="0">
                        optionR := [3]byte{0xE2, 0x8C, 0xA5}
                        c.Output[i], _ = utf8.DecodeRune(optionR[:])</span>
                case control:<span class="cov0" title="0">
                        controlR := [3]byte{0xE2, 0x8C, 0x83}
                        c.Output[i], _ = utf8.DecodeRune(controlR[:])</span>
                case DEL:<span class="cov0" title="0">
                        c.Output[i] = SymbolDEL</span>
                case Replacement:<span class="cov0" title="0">
                        c.Output[i] = rune(SP)</span>
                default:<span class="cov8" title="1">
                        if r &gt;= NUL &amp;&amp; r &lt;= US </span><span class="cov0" title="0">{
                                c.Output[i] = Picture(byte(rune(z) + r))
                        }</span>
                }
        }
}

// RunesShiftJIS tweaks some Unicode picture represenations for Shift-JIS.
func (c *Convert) RunesShiftJIS() <span class="cov8" title="1">{
        const (
                backslash = 92     // /
                tilde     = 126    // ~
                yen       = 0xa5   // 
                overline  = 0x203e // 
                del       = 0xa1   // del
        )
        for i, r := range c.Output </span><span class="cov8" title="1">{
                switch </span>{
                case r == backslash:<span class="cov0" title="0">
                        c.Output[i] = rune(yen)</span>
                case r == tilde:<span class="cov0" title="0">
                        c.Output[i] = rune(overline)</span>
                case r == DEL:<span class="cov0" title="0">
                        c.Output[i] = Picture(del)</span>
                case r &gt; DEL &amp;&amp; r &lt;= rowA,
                        r &gt;= rowE &amp;&amp; r &lt;= NBSP:<span class="cov0" title="0">
                        c.Output[i] = rune(SP)</span>
                }
        }
}

// RunesWindows tweaks some Unicode picture represenations for Windows-125x sets.
func (c *Convert) RunesWindows() <span class="cov8" title="1">{
        for i, r := range c.Output </span><span class="cov8" title="1">{
                switch r </span>{
                case DEL:<span class="cov8" title="1">
                        c.Output[i] = SymbolDEL</span>
                case Replacement:<span class="cov8" title="1">
                        c.Output[i] = rune(SP)</span>
                }
        }
}

// RunesUTF8 tweaks some Unicode picture representation for UTF-8 Basic Latin.
func (c *Convert) RunesUTF8() <span class="cov8" title="1">{
        for i, r := range c.Output </span><span class="cov8" title="1">{
                switch </span>{
                case r == DEL:<span class="cov0" title="0">
                        c.Output[i] = SymbolDEL</span>
                case r &gt; DEL &amp;&amp; r &lt; rowA:<span class="cov0" title="0">
                        c.Output[i] = rune(SP)</span>
                }
        }
}

// Picture converts a byte value to a Unicode Control Picture rune.
func Picture(b byte) rune <span class="cov8" title="1">{
        // code points U+2400 to U+243F
        controlPicture := [3]byte{0xE2, 0x90, b}
        r, _ := utf8.DecodeRune(controlPicture[:])
        return r
}</span>

// EqualLB reports whether r matches the single or multi-byte,
// line break character runes.
func EqualLB(r, nl [2]rune) bool <span class="cov8" title="1">{
        // single-byte line break
        if nl[1] == 0 </span><span class="cov8" title="1">{
                return nl[0] == r[0]
        }</span>
        // mutli-byte
        <span class="cov8" title="1">return bytes.Equal([]byte{byte(r[0]), byte(r[1])},
                []byte{byte(nl[0]), byte(nl[1])})</span>
}

// skipBreak reports whether the rune is a linebreak.
func (c *Convert) skipBreak(i int) bool <span class="cov8" title="1">{
        if !c.Input.UseBreaks </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">l, r0, r1 := len(c.Output)-1, c.Output[i], rune(0)
        if i &lt; l </span><span class="cov8" title="1">{
                // check for multi-byte line breaks
                r1 = c.Output[i+1]
        }</span>
        <span class="cov8" title="1">if EqualLB([2]rune{r0, r1}, c.Input.LineBreak) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// SkipIgnore reports whether the rune should be skipped.
func (c *Convert) SkipIgnore(i int) bool <span class="cov8" title="1">{
        for _, ign := range c.Input.Ignore </span><span class="cov8" title="1">{
                if c.Output[i] == ign </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package fsys handles the opening, reading and writing of files.
package fsys

import (
        "archive/tar"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/bengarrett/retrotxtgo/internal/save"
)

var (
        ErrLB        = errors.New("linebreak runes cannot be empty")
        ErrMax       = errors.New("maximum attempts reached")
        ErrName      = errors.New("name file cannot be a directory")
        ErrNotFound  = errors.New("cannot find the file or sample file")
        ErrPipeEmpty = errors.New("empty text stream from piped stdin (standard input)")
        ErrReader    = errors.New("the r reader cannot be nil")
        ErrWriter    = errors.New("the w writer cannot be nil")
)

// SaveTemp saves bytes to a named temporary file.
// The path to the file is returned.
func SaveTemp(name string, b ...byte) (string, error) <span class="cov8" title="1">{
        _, path, err := save.Save(temp(name), b...)
        if err != nil </span><span class="cov0" title="0">{
                return path, fmt.Errorf("could not save the temporary file: %w", err)
        }</span>
        <span class="cov8" title="1">return path, nil</span>
}

// temp returns a path to the named file
// if it was stored in the system's temporary directory.
func temp(name string) string <span class="cov8" title="1">{
        path := name
        if filepath.Base(name) == name </span><span class="cov8" title="1">{
                path = filepath.Join(os.TempDir(), name)
        }</span>
        <span class="cov8" title="1">return path</span>
}

// Tar add files to a named tar file archive.
func Tar(name string, files ...string) error <span class="cov8" title="1">{
        w, err := os.Create(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer w.Close()
        dst := tar.NewWriter(w)
        defer dst.Close()
        for _, file := range files </span><span class="cov8" title="1">{
                if err := InsertTar(dst, file); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// InsertTar inserts the named file to the TAR writer.
func InsertTar(dst *tar.Writer, name string) error <span class="cov8" title="1">{
        if dst == nil </span><span class="cov0" title="0">{
                return ErrWriter
        }</span>
        <span class="cov8" title="1">src, err := os.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer src.Close()
        s, err := src.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">h := &amp;tar.Header{
                Name:    src.Name(),
                Size:    s.Size(),
                Mode:    int64(s.Mode()),
                ModTime: s.ModTime(),
        }
        if err := dst.WriteHeader(h); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">const size = 4 * 1024
        buf := make([]byte, size)
        if _, err = io.CopyBuffer(dst, src, buf); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Touch creates an empty file at the named location.
func Touch(name string) (string, error) <span class="cov8" title="1">{
        _, path, err := save.Save(name, nil...)
        if err != nil </span><span class="cov8" title="1">{
                return path, fmt.Errorf("could not touch a new file: %w", err)
        }</span>
        <span class="cov8" title="1">return path, nil</span>
}

// Write b to the named file.
// The number of bytes written and the path to the file are returned.
func Write(name string, b ...byte) (int, string, error) <span class="cov8" title="1">{
        return save.Save(name, b...)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package fsys

import (
        "bufio"
        "bytes"
        "errors"
        "fmt"
        "io"
        "os"

        "github.com/bengarrett/retrotxtgo/internal/save"
        "github.com/bengarrett/retrotxtgo/nl"
)

// IsPipe reports whether Stdin (standard input) is piped from another command.
func IsPipe() (bool, error) <span class="cov8" title="1">{
        // source: https://dev.to/napicella/linux-pipes-in-golang-2e8j
        fi, err := os.Stdin.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("could not stat stdin: %w", err)
        }</span>
        <span class="cov8" title="1">return fi.Mode()&amp;os.ModeCharDevice == 0, nil</span>
}

// Read opens and returns the content of the named file.
func Read(name string) ([]byte, error) <span class="cov8" title="1">{
        return ReadAllBytes(name)
}</span>

// ReadAllBytes reads the named file and returns the content as a byte array.
// Create a word and random character generator to make files larger than 64k.
func ReadAllBytes(name string) ([]byte, error) <span class="cov8" title="1">{
        file, err := os.Open(name)
        if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %s", ErrNotFound, name)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        // bufio is the most performant way to scan streamed data
        scanner := bufio.NewScanner(file)
        // optional adjustment to the token size
        // Go by default will scan 64 * 1024 bytes (64KB) per iteration
        const size = 64 * 1024
        buf := []byte{}
        scanner.Buffer(buf, size)
        // required, split scan into Buffer(data, x) sized byte chuncks
        // otherwise scanner will panic on files larger than 64 * 1024 bytes
        scanner.Split(bufio.ScanBytes)
        for scanner.Scan() </span><span class="cov8" title="1">{
                buf = append(buf, scanner.Bytes()...)
        }</span>
        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("scanner %q: %w", name, err)
        }</span>
        <span class="cov8" title="1">return buf, nil</span>
}

// ReadChunk reads and returns the start of the named file.
func ReadChunk(name string, chars int) ([]byte, error) <span class="cov8" title="1">{
        file, err := os.Open(name)
        if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %s", ErrNotFound, name)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        buf := []byte{}
        scanner := bufio.NewScanner(file)
        scanner.Split(bufio.ScanRunes)
        count := 0
        for scanner.Scan() </span><span class="cov8" title="1">{
                count++
                if count &gt; chars </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">buf = append(buf, scanner.Bytes()...)</span>
        }
        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("read chunk could not scan file: %q: %w", name, err)
        }</span>
        <span class="cov8" title="1">return buf, nil</span>
}

// ReadColumns counts the number of characters used per line in the named file.
func ReadColumns(name string) (int, error) <span class="cov8" title="1">{
        return readLineBreaks(name, true)
}</span>

func readLineBreaks(name string, cols bool) (int, error) <span class="cov8" title="1">{
        file, err := os.Open(name)
        if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                return -1, fmt.Errorf("%w: %s", ErrNotFound, name)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        lb, err := ReadLineBreaks(name)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("could not find the line break method: %w", err)
        }</span>
        <span class="cov8" title="1">if !cols </span><span class="cov8" title="1">{
                cnt, err := nl.Lines(file, lb)
                if err != nil </span><span class="cov0" title="0">{
                        return -1, fmt.Errorf("read lines count the file: %q: %w", name, err)
                }</span>
                <span class="cov8" title="1">return cnt, nil</span>
        }
        <span class="cov8" title="1">cnt, err := Columns(file, lb)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("read lines count the file: %q: %w", name, err)
        }</span>
        <span class="cov8" title="1">return cnt, nil</span>
}

// ReadControls counts the number of ANSI escape sequences in the named file.
func ReadControls(name string) (int, error) <span class="cov8" title="1">{
        file, err := os.Open(name)
        if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                return -1, fmt.Errorf("%w: %s", ErrNotFound, name)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        cnt, err := Controls(file)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("read controls could not parse the file: %q: %w", name, err)
        }</span>
        <span class="cov8" title="1">return cnt, nil</span>
}

// ReadLine reads a named file location or a named temporary file and returns its content.
func ReadLine(name string, sys nl.System) (string, error) <span class="cov8" title="1">{
        path, n := temp(name), nl.NewLine(sys)
        file, err := os.OpenFile(path, os.O_RDONLY, save.LogFileMode)
        if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("%w: %s", ErrNotFound, name)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        // bufio is the most performant
        s := ""
        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov8" title="1">{
                s += scanner.Text() + n
        }</span>
        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("read line could not scan file: %w", err)
        }</span>
        <span class="cov8" title="1">return s, nil</span>
}

// ReadLines counts the number of lines in the named file.
func ReadLines(name string) (int, error) <span class="cov8" title="1">{
        return readLineBreaks(name, false)
}</span>

// ReadLineBreaks scans the named file for the most commonly used line break method.
func ReadLineBreaks(name string) ([2]rune, error) <span class="cov8" title="1">{
        z := [2]rune{0, 0}
        file, err := os.Open(name)
        if errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                return z, fmt.Errorf("%w: %s", ErrNotFound, name)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return z, err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        b, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return z, fmt.Errorf("read line breaks could not read the file: %q: %w", name, err)
        }</span>
        <span class="cov8" title="1">return LineBreaks(true, bytes.Runes(b)...), nil</span>
}

// ReadPipe reads data piped by the operating system's STDIN.
// If no data is detected the program will exit.
func ReadPipe() ([]byte, error) <span class="cov8" title="1">{
        b := []byte{}
        scanner := bufio.NewScanner(os.Stdin)
        for scanner.Scan() </span><span class="cov8" title="1">{
                b = append(b, scanner.Bytes()...)
                b = append(b, []byte("\n")...)
        }</span>
        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read pipe could not scan stdin: %w", err)
        }</span>
        <span class="cov8" title="1">if len(b) == 0 </span><span class="cov8" title="1">{
                return nil, ErrPipeEmpty
        }</span>
        <span class="cov8" title="1">return b, nil</span>
}

// ReadRunes returns the number of runes in the named file.
func ReadRunes(name string) (int, error) <span class="cov8" title="1">{
        file, err := os.Open(name)
        if errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("%w: %s", ErrNotFound, name)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        cnt, err := Runes(file)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("read runes could not calculate this file: %q: %w", name, err)
        }</span>
        <span class="cov8" title="1">return cnt, nil</span>
}

// ReadTail reads the named file from the offset position relative to the end of the file.
func ReadTail(name string, offset int) ([]byte, error) <span class="cov8" title="1">{
        file, err := os.Open(name)
        if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: %s", ErrNotFound, name)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        total, err := ReadRunes(name)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("read tail could not read runes: %q: %w", name, err)
        }</span>
        // bufio is the most performant
        <span class="cov8" title="1">scanner := bufio.NewScanner(file)
        scanner.Split(bufio.ScanRunes)
        buf, cnt := []byte{}, 0
        for scanner.Scan() </span><span class="cov8" title="1">{
                cnt++
                if cnt &lt;= (total - offset) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">buf = append(buf, scanner.Bytes()...)</span>
        }
        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read tail could scan file bytes: %q: %w", name, err)
        }</span>
        <span class="cov8" title="1">return buf, nil</span>
}

// ReadText reads a named file location or a named temporary file and returns its content.
func ReadText(name string) (string, error) <span class="cov8" title="1">{
        return ReadLine(name, nl.Host)
}</span>

// ReadWords counts the number of spaced words in the named file.
func ReadWords(name string) (int, error) <span class="cov8" title="1">{
        file, err := os.Open(name)
        if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                return -1, fmt.Errorf("%w: %s", ErrNotFound, name)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        cnt, err := Words(file)
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("read words failed to count words: %q: %w", name, err)
        }</span>
        <span class="cov8" title="1">return cnt, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package fsys

import (
        "bufio"
        "bytes"
        "fmt"
        "io"
        "reflect"
        "runtime"
        "sort"
        "strings"
        "unicode"
        "unicode/utf8"

        "github.com/bengarrett/retrotxtgo/nl"
        "golang.org/x/text/encoding/charmap"
        "golang.org/x/text/transform"
)

const ansiEscape string = "\x1B\x5b" // equals runes 27 and 91 or "ESC["

// LF linefeed.
func LF() [2]rune <span class="cov8" title="1">{
        return [2]rune{nl.LF}
}</span>

// CR carriage return.
func CR() [2]rune <span class="cov8" title="1">{
        return [2]rune{nl.CR}
}</span>

// CRLF carriage return + linefeed.
func CRLF() [2]rune <span class="cov8" title="1">{
        return [2]rune{nl.CR, nl.LF}
}</span>

// LFCR linefeed + carriage return.
func LFCR() [2]rune <span class="cov8" title="1">{
        return [2]rune{nl.LF, nl.CR}
}</span>

// NL new line.
func NL() [2]rune <span class="cov8" title="1">{
        return [2]rune{nl.NL}
}</span>

// NEL next line.
func NEL() [2]rune <span class="cov8" title="1">{
        return [2]rune{nl.NEL}
}</span>

// Columns counts the number of characters used per line in the reader interface.
func Columns(r io.Reader, lb [2]rune) (int, error) <span class="cov8" title="1">{
        if r == nil </span><span class="cov8" title="1">{
                return 0, ErrReader
        }</span>
        <span class="cov8" title="1">if reflect.DeepEqual(lb, [2]rune{}) </span><span class="cov0" title="0">{
                return 0, ErrLB
        }</span>
        <span class="cov8" title="1">lineBreak := []byte{byte(lb[0]), byte(lb[1])}
        if lb[1] == 0 </span><span class="cov8" title="1">{
                lineBreak = []byte{byte(lb[0])}
        }</span>
        <span class="cov8" title="1">p, width := make([]byte, bufio.MaxScanTokenSize), 0
        for </span><span class="cov8" title="1">{
                size, err := r.Read(p)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return -1, fmt.Errorf("columns could not read buffer: %w", err)
                }</span>
                <span class="cov8" title="1">pos := 0
                for pos &lt; size </span><span class="cov8" title="1">{
                        i := bytes.Index(p[pos:], lineBreak)
                        if i == -1 </span><span class="cov0" title="0">{
                                width = size
                                break</span>
                        }
                        <span class="cov8" title="1">pos += i + len(lineBreak)
                        if i &gt; width </span><span class="cov8" title="1">{
                                width = i
                        }</span>
                }
                <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return width, nil</span>
}

// Controls counts the number of ANSI escape controls in the reader interface.
func Controls(r io.Reader) (int, error) <span class="cov8" title="1">{
        if r == nil </span><span class="cov0" title="0">{
                return 0, ErrReader
        }</span>
        <span class="cov8" title="1">lineBreak := []byte(ansiEscape)
        p, count := make([]byte, bufio.MaxScanTokenSize), 0
        for </span><span class="cov8" title="1">{
                size, err := r.Read(p)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("controls could not read buffer: %w", err)
                }</span>
                <span class="cov8" title="1">pos := 0
                for </span><span class="cov8" title="1">{
                        i := bytes.Index(p[pos:], lineBreak)
                        if size == pos </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">if i == -1 </span><span class="cov8" title="1">{
                                return count, nil
                        }</span>
                        <span class="cov8" title="1">pos += i + 1
                        count++</span>
                }
                <span class="cov0" title="0">if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return count, nil</span>
}

// LineBreaks will try to guess the line break representation as a 2 byte value.
// A guess of Unix will return [10, 0], Windows [13, 10], otherwise a [0, 0] value is returned.
func LineBreaks(utf bool, runes ...rune) [2]rune <span class="cov8" title="1">{
        // scan data for possible line breaks
        c := []struct {
                abbr  string
                count int
        }{
                {"lf", 0},   // linux, unix, amiga...
                {"cr", 0},   // 8-bit micros &amp; legacy mac
                {"crlf", 0}, // windows, dos, cp/m...
                {"lfcr", 0}, // acorn bbc micro
                {"nl", 0},   // ibm ebcdic encodings
        }
        l := len(runes) - 1 // range limit
        for i, r := range runes </span><span class="cov8" title="1">{
                switch r </span>{
                case nl.LF:<span class="cov8" title="1">
                        c[0].count = lfCnt(c[0].count, i, l, runes...)</span>
                case nl.CR:<span class="cov8" title="1">
                        if i &lt; l &amp;&amp; runes[i+1] == nl.LF </span><span class="cov8" title="1">{
                                c[2].count++ // crlf
                                continue</span>
                        }
                        <span class="cov8" title="1">if i != 0 &amp;&amp; runes[i-1] == nl.LF </span><span class="cov0" title="0">{
                                // lfcr (already counted)
                                continue</span>
                        }
                        // carriage return on modern terminals will overwrite the existing line of text
                        <span class="cov8" title="1">c[1].count++</span>
                case nl.NL, nl.NEL:<span class="cov8" title="1">
                        if utf &amp;&amp; r == nl.NEL </span><span class="cov0" title="0">{
                                c[4].count++ // NL
                                continue</span>
                        }
                        <span class="cov8" title="1">if r == nl.NL </span><span class="cov8" title="1">{
                                c[4].count++ // NEL
                                continue</span>
                        }
                }
        }
        // sort results
        <span class="cov8" title="1">sort.SliceStable(c, func(i, j int) bool </span><span class="cov8" title="1">{
                return c[i].count &gt; c[j].count
        }</span>)
        <span class="cov8" title="1">return abbr(utf, c[0].abbr)</span>
}

func lfCnt(c, i, l int, runes ...rune) int <span class="cov8" title="1">{
        if len(runes) &lt; i </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov8" title="1">if i &lt; l &amp;&amp; runes[i+1] == nl.CR </span><span class="cov0" title="0">{
                c++ // lfcr
                return c
        }</span>
        <span class="cov8" title="1">if i != 0 &amp;&amp; runes[i-1] == nl.CR </span><span class="cov8" title="1">{
                // crlf (already counted)
                return c
        }</span>
        <span class="cov8" title="1">c++
        return c</span>
}

func abbr(utf bool, s string) [2]rune <span class="cov8" title="1">{
        switch s </span>{
        case "lf":<span class="cov8" title="1">
                return LF()</span>
        case "cr":<span class="cov8" title="1">
                return CR()</span>
        case "crlf":<span class="cov8" title="1">
                return CRLF()</span>
        case "lfcr":<span class="cov0" title="0">
                return LFCR()</span>
        case "nl":<span class="cov8" title="1">
                if utf </span><span class="cov0" title="0">{
                        return NEL()
                }</span>
                <span class="cov8" title="1">return NL()</span>
        }
        <span class="cov0" title="0">return [2]rune{}</span>
}

// LineBreak humanizes the value of LineBreaks().
func LineBreak(r [2]rune, extraInfo bool) string <span class="cov8" title="1">{
        if !extraInfo </span><span class="cov8" title="1">{
                switch r </span>{
                case LF():<span class="cov0" title="0">
                        return "LF"</span>
                case CR():<span class="cov0" title="0">
                        return "CR"</span>
                case CRLF():<span class="cov0" title="0">
                        return "CRLF"</span>
                case LFCR():<span class="cov0" title="0">
                        return "LFCR"</span>
                case NL():<span class="cov8" title="1">
                        return "NL"</span>
                case NEL():<span class="cov0" title="0">
                        return "NEL"</span>
                }
        }
        <span class="cov8" title="1">switch r </span>{
        case LF():<span class="cov0" title="0">
                return fmt.Sprintf("LF (%s)", lfNix())</span>
        case CR():<span class="cov0" title="0">
                return "CR (8-bit microcomputers)"</span>
        case CRLF():<span class="cov0" title="0">
                return "CRLF (Windows, DOS)"</span>
        case LFCR():<span class="cov0" title="0">
                return "LFCR (Acorn BBC)"</span>
        case NL():<span class="cov8" title="1">
                return "NL (IBM EBCDIC)"</span>
        case NEL():<span class="cov0" title="0">
                return "NEL (EBCDIC to Unicode)"</span>
        }
        <span class="cov8" title="1">return "??"</span>
}

func lfNix() string <span class="cov0" title="0">{
        const mac, linux, unix = "macOS", "Linux", "Unix"
        s := strings.Join([]string{mac, linux, unix}, ", ")
        switch runtime.GOOS </span>{
        case "linux":<span class="cov0" title="0">
                s = linux</span>
        case "darwin":<span class="cov0" title="0">
                s = mac</span>
        case "dragonfly", "illumos", "solaris":<span class="cov0" title="0">
                s = unix</span>
        default:<span class="cov0" title="0">
                if strings.HasSuffix(runtime.GOOS, "bsd") </span><span class="cov0" title="0">{
                        s = unix
                }</span>
        }
        <span class="cov0" title="0">return s</span>
}

// Runes returns the number of runes in the reader interface.
func Runes(r io.Reader) (int, error) <span class="cov8" title="1">{
        if r == nil </span><span class="cov0" title="0">{
                return 0, ErrReader
        }</span>
        <span class="cov8" title="1">count := 0
        scanner := bufio.NewScanner(r)
        scanner.Split(bufio.ScanRunes)
        for scanner.Scan() </span><span class="cov8" title="1">{
                count++
        }</span>
        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov8" title="1">{
                return -1, fmt.Errorf("runes could not scan reader: %w", err)
        }</span>
        <span class="cov8" title="1">return count, nil</span>
}

// Words counts the number of spaced words in the reader interface.
func Words(r io.Reader) (int, error) <span class="cov8" title="1">{
        if r == nil </span><span class="cov0" title="0">{
                return 0, ErrReader
        }</span>
        <span class="cov8" title="1">count := 0
        scanner := bufio.NewScanner(r)
        scanner.Split(bufio.ScanWords)
        for scanner.Scan() </span><span class="cov8" title="1">{
                t := scanner.Text()
                r, _ := utf8.DecodeRuneInString(t)
                const size = 65533
                if r &gt;= size </span><span class="cov0" title="0">{
                        continue</span>
                }
                // scan single chars
                <span class="cov8" title="1">if len(t) == 1 </span><span class="cov0" title="0">{
                        if unicode.IsDigit(r) || unicode.IsLetter(r) </span><span class="cov0" title="0">{
                                count++
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                // scan chars within each word
                <span class="cov8" title="1">if Word(t) </span><span class="cov8" title="1">{
                        count++
                }</span>
        }
        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("words could not scan reader: %w", err)
        }</span>
        <span class="cov8" title="1">return count, nil</span>
}

// WordsEBCDIC counts the number of spaced words in the EBCDIC encoded reader interface.
func WordsEBCDIC(r io.Reader) (int, error) <span class="cov8" title="1">{
        if r == nil </span><span class="cov0" title="0">{
                return 0, ErrReader
        }</span>
        // for the purposes of counting words, any EBCDIC code page is fine
        <span class="cov8" title="1">c := transform.NewReader(r, charmap.CodePage037.NewDecoder())
        return Words(c)</span>
}

// Word reports whether content of s contains only characters
// that are comprised of digits, letters and punctuation.
// If a space or line break is encountered the scan ends.
func Word(s string) bool <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for len(s) &gt; 0 </span><span class="cov8" title="1">{
                r, size := utf8.DecodeRuneInString(s)
                if unicode.IsSpace(r) || s == "\n" </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if !unicode.IsDigit(r) &amp;&amp; !unicode.IsLetter(r) &amp;&amp; !unicode.IsPunct(r) </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">s = s[size:]</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package fsys

import (
        "archive/zip"
        "fmt"
        "io"
        "os"
        "path"
        "path/filepath"
        "runtime"
        "strings"

        "github.com/bengarrett/sauce/humanize"
        "golang.org/x/text/language"
)

// Files to zip.
type Files []string

// Zip archive details.
type Zip struct {
        // Zip path and filename.
        Name string
        // Root path of the directory to archive.
        Root string
        // Comment to embed.
        Comment string
        // Overwrite an existing named zip file if encountered.
        Overwrite bool
        // Writer for all the non-error messages, or use io.Discard to suppress.
        Writer io.Writer
}

// Create zip packages and compresses files contained the root directory into an archive using the provided name.
func (z *Zip) Create() error <span class="cov0" title="0">{
        const dotFile = "."
        files := Files{}
        walker := func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("zip walker failed with %q: %w", path, err)
                }</span>
                <span class="cov0" title="0">if info.IsDir() &amp;&amp; info.Name() != filepath.Base(path) </span><span class="cov0" title="0">{
                        return filepath.SkipDir
                }</span>
                // ignore directories because there is no recursive walking
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                // stop recursive walking
                <span class="cov0" title="0">if filepath.Base(filepath.Dir(path)) != filepath.Base(z.Root) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                // ignore posix hidden files
                <span class="cov0" title="0">if info.Name()[:1] == dotFile </span><span class="cov0" title="0">{
                        return nil
                }</span>
                // ignore 0-byte files
                <span class="cov0" title="0">if info.Size() == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">files = append(files, path)
                return nil</span>
        }
        <span class="cov0" title="0">if err := filepath.Walk(z.Root, walker); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return files.Zip(z.Writer, z.Name, z.Comment, z.Overwrite)</span>
}

// Zip packages and compresses files to an archive using the provided name.
func (files *Files) Zip(w io.Writer, name, comment string, ow bool) error <span class="cov0" title="0">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        <span class="cov0" title="0">const (
                overwrite    = os.O_RDWR | os.O_CREATE
                mustNotExist = os.O_RDWR | os.O_CREATE | os.O_EXCL
                readWriteAll = 0o666
        )
        var (
                err error
                n   string
                f   *os.File
        )
        switch ow </span>{
        case true:<span class="cov0" title="0">
                n = name
                f, err = os.OpenFile(n, overwrite, readWriteAll)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("zip create %q: %w", n, err)
                }</span>
                <span class="cov0" title="0">defer f.Close()</span>
        default:<span class="cov0" title="0">
                n, err = UniqueName(name)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("zip name %q: %w", name, err)
                }</span>
                <span class="cov0" title="0">w, err = os.OpenFile(n, mustNotExist, readWriteAll)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("zip create %q: %w", n, err)
                }</span>
                <span class="cov0" title="0">defer f.Close()</span>
        }
        <span class="cov0" title="0">zipper := zip.NewWriter(w)
        defer zipper.Close()
        if comment != "" </span><span class="cov0" title="0">{
                if err := zipper.SetComment(comment); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("zip set comment %q: %w", comment, err)
                }</span>
        }
        <span class="cov0" title="0">for _, fname := range *files </span><span class="cov0" title="0">{
                if err := InsertZip(zipper, fname); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("add zip %q: %w", fname, err)
                }</span>
        }
        <span class="cov0" title="0">if err := zipper.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("zip close: %w", err)
        }</span>
        <span class="cov0" title="0">s, err := os.Stat(n)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("zip could not stat %q: %w", n, err)
        }</span>
        <span class="cov0" title="0">abs, err := filepath.Abs(s.Name())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("zip abs %q: %w", s.Name(), err)
        }</span>
        <span class="cov0" title="0">fmt.Fprintln(w, "created zip file:", abs,
                humanize.Decimal(s.Size(), language.AmericanEnglish))
        return nil</span>
}

// InsertZip adds the named file to a zip archive.
func InsertZip(z *zip.Writer, name string) error <span class="cov0" title="0">{
        if z == nil </span><span class="cov0" title="0">{
                return ErrWriter
        }</span>
        <span class="cov0" title="0">s, err := os.Stat(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fh, err := zip.FileInfoHeader(s)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("file info header: %w", err)
        }</span>
        <span class="cov0" title="0">f, err := z.CreateHeader(fh)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create header: %w", err)
        }</span>
        <span class="cov0" title="0">b, err := Read(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err = f.Write(b); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("io writer: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UniqueName confirms the file name doesn't conflict with an existing file.
// If there is a conflict, a new incremental name will be returned.
func UniqueName(name string) (string, error) <span class="cov8" title="1">{
        const (
                maxAttempts = 9999
                macOS       = "darwin"
                windows     = "windows"
        )
        s, err := os.Stat(name)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return name, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return name, err
        }</span>
        <span class="cov8" title="1">if s.IsDir() </span><span class="cov0" title="0">{
                return "", fmt.Errorf("%q: %w", name, ErrName)
        }</span>
        <span class="cov8" title="1">i := 1
        for </span><span class="cov8" title="1">{
                dir, file := path.Split(name)
                e := path.Ext(file)
                b := strings.TrimSuffix(file, e)
                var n string
                switch runtime.GOOS </span>{
                case macOS:<span class="cov0" title="0">
                        n = fmt.Sprintf("%s %d%s", b, i, e)</span>
                case windows:<span class="cov0" title="0">
                        n = fmt.Sprintf("%s (%d)%s", b, i, e)</span>
                default:<span class="cov8" title="1">
                        n = fmt.Sprintf("%s_%d%s", b, i, e)</span>
                }
                <span class="cov8" title="1">p := filepath.Join(dir, n)
                _, err := os.Stat(p)
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return p, nil
                }</span>
                <span class="cov0" title="0">i++
                if i &gt; maxAttempts </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("unique name aborted after %d attempts: %w", maxAttempts, ErrMax)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package info

import (
        "archive/zip"
        "bytes"
        "crypto/md5"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "hash/crc32"
        "hash/crc64"
        "io"
        "io/fs"
        "os"
        "strconv"
        "strings"
        "sync"
        "text/tabwriter"
        "time"
        "unicode/utf8"

        "github.com/bengarrett/bbs"
        "github.com/bengarrett/retrotxtgo/fsys"
        "github.com/bengarrett/retrotxtgo/nl"
        "github.com/bengarrett/retrotxtgo/term"
        "github.com/bengarrett/sauce"
        "github.com/bengarrett/sauce/humanize"
        gookit "github.com/gookit/color"
        "github.com/mozillazg/go-slugify"
        "github.com/zRedShift/mimemagic"
        "golang.org/x/text/language"
        "golang.org/x/text/message"
)

// Detail is the exported file details.
type Detail struct {
        XMLName    xml.Name     `json:"-"          xml:"file"`
        Name       string       `json:"filename"   xml:"name"`          // Name is the file name.
        Unicode    string       `json:"unicode"    xml:"unicode,attr"`  // Unicode is the file encoding if in Unicode.
        LineBreak  nl.LineBreak `json:"lineBreak"  xml:"line_break"`    // LineBreak is the line break used in the file.
        Count      Stats        `json:"counts"     xml:"counts"`        // Count is the file content statistics.
        Size       Sizes        `json:"size"       xml:"size"`          // Size is the file size in multiples.
        Lines      int          `json:"lines"      xml:"lines"`         // Lines is the number of lines in the file.
        Width      int          `json:"width"      xml:"width"`         // Width is the number of characters per line in the file, this may be inaccurate.
        Modified   ModDates     `json:"modified"   xml:"last_modified"` // Modified is the last modified date of the file.
        Sums       Checksums    `json:"checksums"  xml:"checksums"`     // Sums are the checksums of the file.
        Mime       Content      `json:"mime"       xml:"mime"`          // Mime is the file content metadata.
        Slug       string       `json:"slug"       xml:"id,attr"`       // Slug is the file name slugified.
        Sauce      sauce.Record `json:"sauce"      xml:"sauce"`         // Sauce is the SAUCE metadata.
        ZipComment string       `json:"zipComment" xml:"zip_comment"`   // ZipComment is the zip file comment.
        UTF8       bool         `json:"-"          xml:"-"`             // UTF8 is true if the file is UTF-8 encoded.
        LegacySums bool         `json:"-"          xml:"-"`             // LegacySums is true if the user requests legacy checksums.
        sauceIndex int          // sauceIndex is the index of the SAUCE record in the file.
}

// Checksums act as a fingerprint of the file for uniqueness and data corruption checks.
type Checksums struct {
        CRC32  string `json:"crc32"  xml:"crc32"`  // CRC32 is a cyclic redundancy check of the file.
        CRC64  string `json:"crc64"  xml:"crc64"`  // CRC64 is a cyclic redundancy check of the file.
        MD5    string `json:"md5"    xml:"md5"`    // MD5 is a weak cryptographic hash function.
        SHA256 string `json:"sha256" xml:"sha256"` // SHA256 is a strong cryptographic hash function.
}

// Content metadata from either MIME content type and magic file data.
type Content struct {
        Type  string `json:"-"        xml:"-"`
        Media string `json:"media"    xml:"media"`     // Media is the MIME media type.
        Sub   string `json:"subMedia" xml:"sub_media"` // Sub is the MIME sub type.
        Commt string `json:"comment"  xml:"comment"`   // Commt is the MIME comment.
}

// ModDates is the file last modified dates in multiple output formats.
type ModDates struct {
        Time  time.Time `json:"iso"   xml:"date"`       // Time is the last modified date of the file.
        Epoch int64     `json:"epoch" xml:"epoch,attr"` // Epoch is the last modified date of the file in seconds since the Unix epoch.
}

// Sizes of the file in multiples.
type Sizes struct {
        Bytes   int64  `json:"bytes"   xml:"bytes"`        // Bytes is the size of the file in bytes.
        Decimal string `json:"decimal" xml:"decimal,attr"` // Decimal is the size of the file with decimal units.
        Binary  string `json:"binary"  xml:"binary,attr"`  // Binary is the size of the file with binary units.
}

// Stats are the text file content statistics and counts.
type Stats struct {
        Chars    int `json:"characters"   xml:"characters"`    // Chars is the number of characters in the file.
        Controls int `json:"ansiControls" xml:"ansi_controls"` // Controls is the number of ANSI escape controls in the file.
        Words    int `json:"words"        xml:"words"`         // Words is the number of words in the file, this may be inaccurate.
}

// Format of the output text.
type Format int

const (
        ColorText Format = iota // ColorText is ANSI colored text.
        PlainText               // PlainText is standard text.
        JSON                    // JSON data-interchange format.
        JSONMin                 // JSONMin is JSON data minified.
        XML                     // XML markup data.
)

const (
        uc8         = "UTF-8"
        ans         = "ANSI controls"
        cmmt        = "comment"
        txt         = "text"
        zipComment  = "zip comment"
        octetStream = "application/octet-stream"
        zipType     = "application/zip"
)

// lang returns the English Language tag used for numeric syntax formatting.
func lang() language.Tag <span class="cov8" title="1">{
        return language.English
}</span>

// Ctrls counts the number of ANSI escape controls in the named file.
func (d *Detail) Ctrls(name string) error <span class="cov8" title="1">{
        r, err := os.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer r.Close()
        cnt, err := fsys.Controls(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">d.Count.Controls = cnt
        return nil</span>
}

// protects the marshal function which is not thread safe due to the use of gookit.Enable.
var marshalMu sync.Mutex //nolint:gochecknoglobals

// Marshal writes the Detail data in a given format syntax.
func (d *Detail) Marshal(w io.Writer, f Format) error <span class="cov8" title="1">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">const jsTab = "    "
        const xmlTab = "\t"
        var err error
        switch f </span>{
        case ColorText:<span class="cov8" title="1">
                marshalMu.Lock()
                err = d.marshal(w, true)
                marshalMu.Unlock()</span>
        case PlainText:<span class="cov8" title="1">
                marshalMu.Lock()
                err = d.marshal(w, false)
                marshalMu.Unlock()</span>
        case JSON:<span class="cov8" title="1">
                b, errj := json.MarshalIndent(d, "", jsTab)
                if errj != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("detail json indent marshal: %w", errj)
                }</span>
                <span class="cov8" title="1">_, err = w.Write(b)</span>
        case JSONMin:<span class="cov8" title="1">
                b, errj := json.Marshal(d)
                if errj != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("detail json marshal: %w", errj)
                }</span>
                <span class="cov8" title="1">_, err = w.Write(b)</span>
        case XML:<span class="cov8" title="1">
                b, errj := xml.MarshalIndent(d, "", xmlTab)
                if errj != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("detail xml marshal: %w", errj)
                }</span>
                <span class="cov8" title="1">_, err = w.Write(b)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("detail marshal %q: %w", f, ErrFmt)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("detail marshal %q: %w", f, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// MimeUnknown detects non-Standard legacy data.
func (d *Detail) MimeUnknown() <span class="cov8" title="1">{
        if d.Mime.Commt != "unknown" </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">if d.Count.Controls &gt; 0 </span><span class="cov0" title="0">{
                d.Mime.Commt = "Text document with ANSI controls"
                return
        }</span>
        <span class="cov0" title="0">switch d.LineBreak.Decimal </span>{
        case [2]rune{21}, [2]rune{133}:<span class="cov0" title="0">
                d.Mime.Commt = "EBCDIC encoded text document"
                return</span>
        }
        <span class="cov0" title="0">if d.Mime.Type == octetStream </span><span class="cov0" title="0">{
                if !d.UTF8 &amp;&amp; d.Count.Words &gt; 0 </span><span class="cov0" title="0">{
                        d.Mime.Commt = "US-ASCII encoded text document"
                        return
                }</span>
        }
}

// Parse the file and the raw data content.
func (d *Detail) Parse(name string, data ...byte) error <span class="cov8" title="1">{
        routines := 5
        if d.LegacySums </span><span class="cov8" title="1">{
                routines += 3
        }</span>
        <span class="cov8" title="1">wg := sync.WaitGroup{}
        wg.Add(routines)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                d.sauceIndex = sauce.Index(data)
                if d.sauceIndex &gt; 0 </span><span class="cov8" title="1">{
                        d.Sauce = sauce.Decode(data)
                }</span>
        }()
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                d.mime(name, data...)
        }</span>()
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                stat, _ := os.Stat(name)
                d.input(len(data), stat)
        }</span>()
        <span class="cov8" title="1">if d.LegacySums </span><span class="cov8" title="1">{
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        crc32sum := crc32.ChecksumIEEE(data)
                        d.Sums.CRC32 = strconv.FormatUint(uint64(crc32sum), 16)
                }</span>()
                <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        crc64sum := crc64.Checksum(data, crc64.MakeTable(crc64.ECMA))
                        d.Sums.CRC64 = strconv.FormatUint(crc64sum, 16)
                }</span>()
                <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        md5sum := md5.Sum(data)
                        d.Sums.MD5 = hex.EncodeToString(md5sum[:])
                }</span>()
        }
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                shasum := sha256.Sum256(data)
                d.Sums.SHA256 = hex.EncodeToString(shasum[:])
        }</span>()
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                d.UTF8 = utf8.Valid(data)
                d.Unicode = unicode(d.UTF8, data...)
        }</span>()
        <span class="cov8" title="1">wg.Wait()
        return nil</span>
}

func unicode(uni bool, b ...byte) string <span class="cov8" title="1">{
        UTF8Bom := []byte{0xEF, 0xBB, 0xBF}
        // little endianness, x86, ARM
        UTF16LEBom := []byte{0xFF, 0xFE}
        UTF32LEBom := []byte{0xFF, 0xFE, 0x00, 0x00}
        // big endianness, legacy mainframes, RISC
        UTF16BEBom := []byte{0xFE, 0xFF}
        UTF32BEBom := []byte{0x00, 0x00, 0xFE, 0xFF}
        switch </span>{
        case bytes.HasPrefix(b, UTF8Bom):<span class="cov0" title="0">
                return uc8</span>
        case bytes.HasPrefix(b, UTF16LEBom):<span class="cov0" title="0">
                return "UTF-16 LE"</span>
        case bytes.HasPrefix(b, UTF16BEBom):<span class="cov0" title="0">
                return "UTF-16 BE"</span>
        case bytes.HasPrefix(b, UTF32LEBom):<span class="cov0" title="0">
                return "UTF-32 LE"</span>
        case bytes.HasPrefix(b, UTF32BEBom):<span class="cov0" title="0">
                return "UTF-32 BE"</span>
        default:<span class="cov8" title="1">
                if uni </span><span class="cov8" title="1">{
                        return "UTF-8 compatible"
                }</span>
                <span class="cov8" title="1">return "no"</span>
        }
}

func sauceDate(s string) string <span class="cov8" title="1">{
        t, err := time.Parse("20060102", s) // CCYYMMDD
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return humanize.DMY.Format(t.UTC())</span>
}

// Read and parse the named file and content.
func (d *Detail) Read(name string) error <span class="cov8" title="1">{
        // Read file content
        p, err := fsys.ReadAllBytes(name)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return d.Parse(name, p...)</span>
}

// ValidText reports whether the MIME content-type value is valid for text files.
func ValidText(mime string) bool <span class="cov8" title="1">{
        s := strings.Split(mime, "/")
        const req = 2
        if len(s) != req </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if s[0] == txt </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if mime == octetStream </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Len counts the number of characters used per line in the named file.
func (d *Detail) Len(name string) error <span class="cov8" title="1">{
        r, err := os.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer r.Close()
        w, err := fsys.Columns(r, d.LineBreak.Decimal)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if w &lt; 0 </span><span class="cov0" title="0">{
                w = d.Count.Chars
        }</span>
        <span class="cov8" title="1">d.Width = w
        return nil</span>
}

// Words counts the number of words used in the named file.
func (d *Detail) Words(name string) error <span class="cov8" title="1">{
        r, err := os.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer r.Close()
        switch d.LineBreak.Decimal </span>{
        case [2]rune{nl.NL}, [2]rune{nl.NEL}:<span class="cov0" title="0">
                if d.Count.Words, err = fsys.WordsEBCDIC(r); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        default:<span class="cov8" title="1">
                if d.Count.Words, err = fsys.Words(r); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// input parses simple statistical data on the file.
func (d *Detail) input(data int, stat fs.FileInfo) <span class="cov8" title="1">{
        if stat != nil </span><span class="cov8" title="1">{
                b := stat.Size()
                d.Size.Bytes = b
                d.Size.Binary = humanize.Binary(b, lang())
                d.Size.Decimal = humanize.Decimal(b, lang())
                d.Name = stat.Name()
                d.Modified.Time = stat.ModTime().UTC()
                d.Modified.Epoch = stat.ModTime().Unix()
                d.Slug = slugify.Slugify(stat.Name())
                return
        }</span>
        <span class="cov8" title="1">b := int64(data)
        d.Size.Bytes = b
        d.Size.Binary = humanize.Binary(b, lang())
        d.Size.Decimal = humanize.Decimal(b, lang())
        d.Name = "n/a (stdin)"
        d.Slug = "n/a"
        d.Modified.Time = time.Now()
        d.Modified.Epoch = time.Now().Unix()</span>
}

// marshal returns the marshaled detail data as plain or color text.
//
// Note: this function is not thread safe due to the use of gookit.Enable set by color bool.
func (d *Detail) marshal(w io.Writer, color bool) error <span class="cov8" title="1">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">const padding, width = 10, 80
        info := func(s string) string </span><span class="cov8" title="1">{
                return s + "\t"
        }</span>
        <span class="cov8" title="1">gookit.Enable = color
        term.Head(w, width, "File information")
        fmt.Fprintln(w)
        data := d.marshalled()
        l := len(fmt.Sprintf(" filename%s%s", strings.Repeat(" ", padding), data[0].v))
        const tabWidth = 8
        tw := tabwriter.NewWriter(w, 0, tabWidth, 0, '\t', 0)
        for _, x := range data </span><span class="cov8" title="1">{
                if !d.validate(x) || d.skip(x) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if x.k == zipComment </span><span class="cov8" title="1">{
                        if x.v != "" </span><span class="cov0" title="0">{
                                term.HR(tw, l)
                                fmt.Fprintln(tw, x.v)
                                if d.sauceIndex &lt;= 0 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                // divider for sauce metadata
                                <span class="cov0" title="0">term.HR(tw, l)
                                continue</span>
                        }
                        <span class="cov8" title="1">if d.sauceIndex &lt;= 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        // divider for sauce metadata
                        <span class="cov8" title="1">term.HR(tw, l)
                        continue</span>
                }
                <span class="cov8" title="1">fmt.Fprintf(tw, "\t %s\t  %s\n", x.k, info(x.v))
                if x.k == cmmt </span><span class="cov8" title="1">{
                        if d.Sauce.Comnt.Count &lt;= 0 </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return tw.Flush()</span>
}

// marshalled returns the data structure used for print marshaling.
func (d *Detail) marshalled() []struct{ k, v string } <span class="cov8" title="1">{
        const (
                noBreakSpace     = "\u00A0"
                symbolForNewline = "\u2424"
        )
        p := message.NewPrinter(lang())
        data := []struct {
                k, v string
        }{
                {k: "slug", v: d.Slug},
                {k: "filename", v: d.Name},
                {k: "filetype", v: d.Mime.Commt},
                {k: "Unicode", v: d.Unicode},
                {k: "line break", v: fsys.LineBreak(d.LineBreak.Decimal, true)},
                {k: "characters", v: p.Sprint(d.Count.Chars)},
                {k: ans, v: p.Sprint(d.Count.Controls)},
                {k: "words", v: p.Sprint(d.Count.Words)},
                {k: "size", v: d.Size.Decimal},
                {k: "lines", v: p.Sprint(d.Lines)},
                {k: "width", v: p.Sprint(d.Width)},
                {k: "modified", v: humanize.DMY.Format(d.Modified.Time.UTC())},
                {k: "media mime type", v: d.Mime.Type},
                {k: "SHA256 checksum", v: d.Sums.SHA256},
                {k: "CRC64 ECMA", v: d.Sums.CRC64},
                {k: "CRC32", v: d.Sums.CRC32},
                {k: "MD5", v: d.Sums.MD5},
                {k: zipComment, v: d.ZipComment},
                // sauce data
                {k: "title", v: d.Sauce.Title},
                {k: "author", v: d.Sauce.Author},
                {k: "group", v: d.Sauce.Group},
                {k: "date", v: sauceDate(d.Sauce.Date.Value)},
                {k: "original size", v: d.Sauce.FileSize.Decimal},
                {k: "file type", v: d.Sauce.File.Name},
                {k: "data type", v: d.Sauce.Data.Name},
                {k: "description", v: d.Sauce.Desc},
                {k: d.Sauce.Info.Info1.Info, v: strconv.FormatUint(uint64(d.Sauce.Info.Info1.Value), 10)},
                {k: d.Sauce.Info.Info2.Info, v: strconv.FormatUint(uint64(d.Sauce.Info.Info2.Value), 10)},
                {k: d.Sauce.Info.Info3.Info, v: strconv.FormatUint(uint64(d.Sauce.Info.Info3.Value), 10)},
                {k: "interpretation", v: d.Sauce.Info.Flags.String()},
        }
        // sauce comment
        for i, line := range d.Sauce.Comnt.Comment </span><span class="cov8" title="1">{
                comment := struct{ k, v string }{
                        k: noBreakSpace, v: line,
                }
                if i == 0 </span><span class="cov8" title="1">{
                        comment.k = cmmt
                }</span>
                <span class="cov8" title="1">data = append(data, comment)</span>
        }
        <span class="cov8" title="1">return data</span>
}

func (d *Detail) mime(name string, data ...byte) <span class="cov8" title="1">{
        mm := mimemagic.MatchMagic(data)
        d.Mime.Media = mm.Media
        d.Mime.Sub = mm.Subtype
        d.Mime.Type = fmt.Sprintf("%s/%s", mm.Media, mm.Subtype)
        d.Mime.Commt = mm.Comment
        if d.Mime.Commt == "plain text document" </span><span class="cov8" title="1">{
                reader := bytes.NewReader(data)
                if s := bbs.Find(reader).Name(); s != "" </span><span class="cov0" title="0">{
                        d.Mime.Commt += fmt.Sprintf(" with %s BBS color codes", s)
                }</span>
        }
        <span class="cov8" title="1">if ValidText(d.Mime.Type) </span><span class="cov8" title="1">{
                var err error
                b := bytes.NewBuffer(data)
                if d.Count.Chars, err = fsys.Runes(b); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stdout, "mine sniffer failure, %s\n", err)
                }</span>
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">if d.Mime.Type == zipType </span><span class="cov0" title="0">{
                r, e := zip.OpenReader(name)
                if e != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stdout, "open zip file failure: %s\n", e)
                }</span>
                <span class="cov0" title="0">if r == nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">defer r.Close()
                d.ZipComment = r.Comment</span>
        }
}

// skip reports whether the key and value data should be skipped.
func (d *Detail) skip(x struct{ k, v string }) bool <span class="cov8" title="1">{
        if !d.LegacySums </span><span class="cov8" title="1">{
                switch x.k </span>{
                case "CRC32", "CRC64 ECMA", "MD5":<span class="cov8" title="1">
                        return true</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// validate reports whether the key and value data validate.
func (d *Detail) validate(x struct{ k, v string }) bool <span class="cov8" title="1">{
        if !ValidText(d.Mime.Type) </span><span class="cov8" title="1">{
                switch x.k </span>{
                case uc8, "line break", "characters", ans, "words", "lines", "width":<span class="cov8" title="1">
                        return false</span>
                }
        } else<span class="cov8" title="1"> if x.k == ans </span><span class="cov8" title="1">{
                if d.Count.Controls == 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">if x.k == "description" &amp;&amp; x.v == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if x.k == d.Sauce.Info.Info1.Info &amp;&amp; d.Sauce.Info.Info1.Value == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if x.k == d.Sauce.Info.Info2.Info &amp;&amp; d.Sauce.Info.Info2.Value == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if x.k == d.Sauce.Info.Info3.Info &amp;&amp; d.Sauce.Info.Info3.Value == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if x.k == "interpretation" &amp;&amp; x.v == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Package info that extracts and returns file statistics and metadata.
package info

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "os"
        "sync"

        "github.com/bengarrett/retrotxtgo/fsys"
        "github.com/bengarrett/retrotxtgo/nl"
        "github.com/karrick/godirwalk"
        "golang.org/x/sync/errgroup"
)

var (
        ErrFmt  = errors.New("format is not known")
        ErrName = errors.New("name value cannot be empty")
)

// Info parses the named file and writes the details in a formal syntax.
func Info(w io.Writer, name, format string, chksums bool) error <span class="cov8" title="1">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">failure := fmt.Sprintf("info on %s failed", name)
        if name == "" </span><span class="cov0" title="0">{
                return ErrName
        }</span>
        <span class="cov8" title="1">f, err := output(format)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s, err := os.Stat(name)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", failure, err)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", failure, err)
        }</span>
        <span class="cov8" title="1">if !s.IsDir() </span><span class="cov8" title="1">{
                if err := Marshal(w, name, chksums, f); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", failure, err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        // godirwalk.Walk is more performant than the standard library filepath.Walk
        <span class="cov0" title="0">err = godirwalk.Walk(name, &amp;godirwalk.Options{
                Callback: func(osPathname string, de *godirwalk.Dirent) error </span><span class="cov0" title="0">{
                        if skip, err := de.IsDirOrSymlinkToDir(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span> else<span class="cov0" title="0"> if skip </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return Marshal(w, osPathname, chksums, f)</span>
                },
                ErrorCallback: func(_ string, _ error) godirwalk.ErrorAction <span class="cov0" title="0">{
                        return godirwalk.SkipNode
                }</span>,
                Unsorted: true, // set true for faster yet non-deterministic enumeration
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("info could not walk directory: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// output converts the argument string to a format type.
func output(arg string) (Format, error) <span class="cov8" title="1">{
        switch arg </span>{
        case "color", "c", "":<span class="cov8" title="1">
                return ColorText, nil</span>
        case "text", "t":<span class="cov8" title="1">
                return PlainText, nil</span>
        case "json", "j":<span class="cov8" title="1">
                return JSON, nil</span>
        case "json.min", "jm":<span class="cov8" title="1">
                return JSONMin, nil</span>
        case "xml", "x":<span class="cov8" title="1">
                return XML, nil</span>
        }
        <span class="cov0" title="0">return -1, fmt.Errorf("%w: %s", ErrFmt, arg)</span>
}

// Marshal and write the metadata and system details of a named file.
func Marshal(w io.Writer, name string, chksums bool, f Format) error <span class="cov8" title="1">{
        if w == nil </span><span class="cov8" title="1">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">var d Detail
        d.LegacySums = chksums // this must go before d.Read()
        if err := d.Read(name); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if ValidText(d.Mime.Type) </span><span class="cov8" title="1">{
                var err error
                // get the required line breaks chars before running the multiple tasks
                if d.LineBreak.Decimal, err = fsys.ReadLineBreaks(name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">d.LineBreak.Find(d.LineBreak.Decimal)
                g := errgroup.Group{}
                var mu sync.Mutex
                g.Go(func() error </span><span class="cov8" title="1">{
                        return d.Ctrls(name)
                }</span>)
                <span class="cov8" title="1">g.Go(func() error </span><span class="cov8" title="1">{
                        return d.Len(name)
                }</span>)
                <span class="cov8" title="1">g.Go(func() error </span><span class="cov8" title="1">{
                        i, err := d.LineBreak.Total(name)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">mu.Lock()
                        d.Lines = i
                        mu.Unlock()
                        return nil</span>
                })
                <span class="cov8" title="1">g.Go(func() error </span><span class="cov8" title="1">{
                        return d.Words(name)
                }</span>)
                <span class="cov8" title="1">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">d.MimeUnknown()</span>
        }
        <span class="cov8" title="1">if err := d.Marshal(w, f); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">printnl(w, f)
        return nil</span>
}

// Stream parses piped data and writes out the details in a specific syntax.
func Stream(w io.Writer, format string, data ...byte) error <span class="cov8" title="1">{ //nolint:funlen
        if w == nil </span><span class="cov8" title="1">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">var d Detail
        f, e := output(format)
        if e != nil </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov8" title="1">if err := d.Parse("", data...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !ValidText(d.Mime.Type) </span><span class="cov8" title="1">{
                return marshall(d, w, f)
        }</span>
        <span class="cov8" title="1">d.LineBreak.Find(fsys.LineBreaks(true, []rune(string(data))...))
        g := errgroup.Group{}
        var mu sync.Mutex
        g.Go(func() error </span><span class="cov8" title="1">{
                val, err := fsys.Controls(bytes.NewReader(data))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">mu.Lock()
                d.Count.Controls = val
                mu.Unlock()
                return nil</span>
        })
        <span class="cov8" title="1">g.Go(func() error </span><span class="cov8" title="1">{
                val, err := nl.Lines(bytes.NewReader(data), d.LineBreak.Decimal)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">mu.Lock()
                d.Lines = val
                mu.Unlock()
                return nil</span>
        })
        <span class="cov8" title="1">g.Go(func() error </span><span class="cov8" title="1">{
                val, err := fsys.Columns(bytes.NewReader(data), d.LineBreak.Decimal)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if val &lt; 0 </span><span class="cov0" title="0">{
                        val = d.Count.Chars
                }</span>
                <span class="cov8" title="1">mu.Lock()
                d.Width = val
                mu.Unlock()
                return nil</span>
        })
        <span class="cov8" title="1">g.Go(func() error </span><span class="cov8" title="1">{
                val, err := fsys.Words(bytes.NewReader(data))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">mu.Lock()
                d.Count.Words = val
                mu.Unlock()
                return nil</span>
        })
        <span class="cov8" title="1">if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">d.MimeUnknown()
        return marshall(d, w, f)</span>
}

func marshall(d Detail, w io.Writer, f Format) error <span class="cov8" title="1">{
        if err := d.Marshal(w, f); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">printnl(w, f)
        return nil</span>
}

// printnl appends a newline to JSON and XML text.
func printnl(w io.Writer, f Format) <span class="cov8" title="1">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">switch f </span>{
        case ColorText, PlainText:<span class="cov8" title="1">
                return</span>
        case JSON, JSONMin, XML:<span class="cov8" title="1">
                fmt.Fprintln(w)
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package mock

import (
        "crypto/rand"
        "errors"
        "fmt"
        "log"
        "math"
        "math/big"
        mr "math/rand"
        "os"
        "path/filepath"

        "github.com/bengarrett/retrotxtgo/internal/save"
        "github.com/bengarrett/retrotxtgo/internal/tmp"
)

var (
        ErrMax = errors.New("maxpow value cannot be less than or equal to zero")
        ErrZB  = errors.New("zero bytes written")
)

const (
        xPow = 1000
        yPow = 2
)

// Input returns a file pointer to a temporary file containing the input string.
func Input(input string) (*os.File, error) <span class="cov0" title="0">{
        s := []byte(input)
        r, w, err := os.Pipe()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer w.Close()
        if _, err = w.Write(s); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r, nil</span>
}

// T are short ASCII and Unicode strings used in various unit tests.
func T() map[string]string <span class="cov0" title="0">{
        return map[string]string{
                // Newline sample using yjr operating system defaults
                "Newline": "a\nb\nc...\n",
                // Symbols for Unicode Wingdings
                "Symbols": `[||]`,
                // Tabs and Unicode glyphs
                "Tabs": "\tSkull and crossbones\n\n\tPeace symbol\n\n\tRecycling",
                // Escapes and control codes.
                "Escapes": "bell:\a,back:\b,tab:\t,form:\f,vertical:\v,quote:\"",
                // Digits in various formats
                "Digits": "\xb0\260\u0170\U00000170",
        }
}</span>

// maxPow calculates and returns the maximum value of yPow raised to the power of xPow.
// It always confirms that the value is safe to use with rand.Int,
// that panics if the y value is less than or equal to zero.
func maxPow() *big.Int <span class="cov0" title="0">{
        y := big.NewInt(int64(math.Pow(xPow, yPow)))
        x := big.NewInt(1)
        if x.Cmp(y) == 1 </span><span class="cov0" title="0">{
                log.Fatalf("%s: %s", ErrMax, y)
        }</span>
        <span class="cov0" title="0">return y</span>
}

// FileExample saves the string to a randomized, threadsafe filename.
// The path to the file is returned.
func FileExample(s string) string <span class="cov0" title="0">{
        v, err := rand.Int(rand.Reader, maxPow())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">name := fmt.Sprintf("rt_fs_save%s.txt", v)
        path, err := SaveTemp(name, []byte(s)...)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">return path</span>
}

// LargeExample generates and saves a 800k file of filler us-ascii text
// to a randomized, threadsafe filename. The path to the file is returned.
func LargeExample() string <span class="cov0" title="0">{
        v, err := rand.Int(rand.Reader, maxPow())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">const sizeMB = 0.8
        name := fmt.Sprintf("rs_mega_example_save%s.txt", v)
        s := Filler(sizeMB)
        path, err := SaveTemp(name, []byte(s)...)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">return path</span>
}

// MegaExample generates and saves a 1.5MB file of filler us-ascii text
// to a randomized, threadsafe filename. The path to the file is returned.
func MegaExample() string <span class="cov0" title="0">{
        v, err := rand.Int(rand.Reader, maxPow())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">const sizeMB = 1.5
        name := fmt.Sprintf("rs_giga_mega_save%s.txt", v)
        s := Filler(sizeMB)
        path, err := SaveTemp(name, []byte(s)...)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">return path</span>
}

// ByteExample saves a string of multibyte Unicode characters, tabs and
// newlines to a randomized, threadsafe filename. The path to the file is
// returned.
func ByteExample() string <span class="cov0" title="0">{
        v, err := rand.Int(rand.Reader, maxPow())
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">name := fmt.Sprintf("rs_byte_chars_save%s.txt", v)
        b := []byte(T()["Tabs"]) // Tabs and Unicode glyphs
        path, err := SaveTemp(name, b...)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">return path</span>
}

// Filler generates random us-ascii text.
func Filler(sizeMB float64) string <span class="cov8" title="1">{
        if sizeMB &lt;= 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        // make characters to randomize
        <span class="cov8" title="1">const (
                // ascii code points (rune codes)
                start    = 33  // "!"
                end      = 122 // "z"
                charsLen = end - start + 1
        )
        chars := make([]rune, charsLen)
        for c, i := 0, start; i &lt;= end; i++ </span><span class="cov8" title="1">{
                chars[c] = rune(i)
                c++
        }</span>
        // initialize rune slice
        <span class="cov8" title="1">const base, exp = 1000, 2
        f := (math.Pow(base, exp) * sizeMB)
        s := make([]rune, int(f))
        // generate random string
        for i := range s </span><span class="cov8" title="1">{
                s[i] = chars[mr.Intn(charsLen)]
        }</span>
        <span class="cov8" title="1">return string(s)</span>
}

type DirTests []struct {
        Name    string
        WantDir string
}

func WindowsTests(h, hp, s, w, wp string) DirTests <span class="cov0" title="0">{
        return DirTests{
                {fmt.Sprintf("C:%shome%suser", s, s), fmt.Sprintf("C:%shome%suser", s, s)},
                {"~", h},
                {filepath.Join("~", "foo"), filepath.Join(h, "foo")},
                {".", w},
                {fmt.Sprintf(".%sfoo", s), filepath.Join(w, "foo")},
                {fmt.Sprintf("..%sfoo", s), filepath.Join(wp, "foo")},
                {fmt.Sprintf("~%s..%sfoo", s, s), filepath.Join(hp, "foo")},
                {fmt.Sprintf("d:%sroot%sfoo%s..%sblah", s, s, s, s), fmt.Sprintf("D:%sroot%sblah", s, s)},
                {fmt.Sprintf("z:%sroot%sfoo%s.%sblah", s, s, s, s), fmt.Sprintf("Z:%sroot%sfoo%sblah", s, s, s)},
        }
}</span>

func NixTests(h, hp, s, w, wp string) DirTests <span class="cov0" title="0">{
        return DirTests{
                {fmt.Sprintf("%shome%suser", s, s), fmt.Sprintf("%shome%suser", s, s)},
                {"~", h},
                {filepath.Join("~", "foo"), filepath.Join(h, "foo")},
                {".", w},
                {fmt.Sprintf(".%sfoo", s), filepath.Join(w, "foo")},
                {fmt.Sprintf("..%sfoo", s), filepath.Join(wp, "foo")},
                {fmt.Sprintf("~%s..%sfoo", s, s), filepath.Join(hp, "foo")},
                {fmt.Sprintf("%sroot%sfoo%s..%sblah", s, s, s, s), fmt.Sprintf("%sroot%sblah", s, s)},
                {fmt.Sprintf("%sroot%sfoo%s.%sblah", s, s, s, s), fmt.Sprintf("%sroot%sfoo%sblah", s, s, s)},
        }
}</span>

// SaveTemp saves bytes to a named temporary file.
func SaveTemp(name string, b ...byte) (string, error) <span class="cov0" title="0">{
        i, path, err := save.Save(tmp.File(name), b...)
        if err != nil </span><span class="cov0" title="0">{
                return path, fmt.Errorf("could not save the temporary file: %w", err)
        }</span>
        <span class="cov0" title="0">if i == 0 &amp;&amp; len(b) &gt; 0 </span><span class="cov0" title="0">{
                return path, fmt.Errorf("%w: %s", ErrZB, path)
        }</span>
        <span class="cov0" title="0">return path, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package save

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
)

const (
        DirMode     os.FileMode = 0o700
        FileMode    os.FileMode = 0o660
        LogFileMode os.FileMode = 0o600
)

// Save bytes to the named file location.
// The return values are the number of bytes written, the absolute path and filename, and any error.
func Save(name string, b ...byte) (int, string, error) <span class="cov8" title="1">{
        if _, err := dir(name); err != nil </span><span class="cov0" title="0">{
                return 0, "", fmt.Errorf("save could not open directory %q: %w", name, err)
        }</span>
        <span class="cov8" title="1">path := name
        const overwrite = os.O_RDWR | os.O_CREATE | os.O_TRUNC
        file, err := os.OpenFile(path, overwrite, FileMode)
        if err != nil </span><span class="cov8" title="1">{
                return 0, path, fmt.Errorf("save could not open file %q: %w", path, err)
        }</span>
        <span class="cov8" title="1">defer file.Close()
        // bufio is the most performant
        w := bufio.NewWriter(file)
        written := 0
        for i, c := range b </span><span class="cov8" title="1">{
                written = i
                if err := w.WriteByte(c); err != nil </span><span class="cov0" title="0">{
                        return 0, path, fmt.Errorf("save could not write bytes: %w", err)
                }</span>
        }
        <span class="cov8" title="1">if err := w.Flush(); err != nil </span><span class="cov0" title="0">{
                return 0, path, fmt.Errorf("save could not flush the writer: %w", err)
        }</span>
        <span class="cov8" title="1">path, err = filepath.Abs(file.Name())
        if err != nil </span><span class="cov0" title="0">{
                return 0, path, fmt.Errorf("save could not find the absolute filename: %w", err)
        }</span>
        <span class="cov8" title="1">return written, path, nil</span>
}

// dir creates the named path directory if it doesn't exist.
func dir(name string) (string, error) <span class="cov8" title="1">{
        path := filepath.Dir(name)
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                if err := os.MkdirAll(path, DirMode); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("dir could not make the directory: %s %s: %w", DirMode, path, err)
                }</span>
        }
        <span class="cov8" title="1">return path, nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package tmp

import (
        "os"
        "path/filepath"
)

// File returns a path to the named file
// if it was stored in the system's temporary directory.
func File(name string) string <span class="cov8" title="1">{
        path := name
        if filepath.Base(name) == name </span><span class="cov8" title="1">{
                path = filepath.Join(os.TempDir(), name)
        }</span>
        <span class="cov8" title="1">return path</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package logs

import (
        "errors"
        "fmt"
        "os"
        "strings"

        "github.com/bengarrett/retrotxtgo/meta"
)

var (
        ErrNoArgs  = errors.New("no arguments were given for the logs executer")
        ErrShort   = errors.New("word count is too short, it requires at least 3 words")
        ErrCmd     = errors.New("the command is invalid")
        ErrFlag    = errors.New("the flag does not work with this command")
        ErrFlagNil = errors.New("the flag with a value must be included with this command")
        ErrNotBool = errors.New("the value must be either true or false")
        ErrNotInt  = errors.New("the value must be a number")
        ErrNotInts = errors.New("the value must be a single or a list of numbers")
        ErrNotNil  = errors.New("the value cannot be empty")
)

const (
        minWords       = 3
        flagChoice     = "invalid option choice"
        flagRequired   = "required flag(s)"
        flagSyntax     = "bad flag"
        invalidCommand = "invalid command"
        invalidFlag    = "flag needs"
        invalidSlice   = "invalid slice"
        invalidType    = "invalid argument"
        exec           = "logs executer problem"
)

// FatalSubCmd prints a problem highlighting the unsupported sub-command.
func FatalSubCmd(usage string, args ...string) <span class="cov0" title="0">{
        args = append(args, usage)
        var err error
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                err = fmt.Errorf("%w: %s", ErrCmd, args[0])
        }</span>
        <span class="cov0" title="0">if s := Execute(err, false, args...); s != "" </span><span class="cov0" title="0">{
                fmt.Fprintln(os.Stderr, s)
                os.Exit(OSErr)
        }</span>
}

// Execute is the error handler for command flags and arguments.
func Execute(err error, test bool, args ...string) string <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">words := strings.Split(fmt.Sprintf("%s", err), " ")
        argsCnt, wordCnt := len(args), len(words)
        if wordCnt &lt; minWords </span><span class="cov0" title="0">{
                e := fmt.Errorf("%s: %w", exec, ErrShort)
                if test </span><span class="cov0" title="0">{
                        return e.Error()
                }</span>
                <span class="cov0" title="0">Fatal(e)</span>
        }
        <span class="cov0" title="0">if argsCnt == 0 </span><span class="cov0" title="0">{
                Fatal(err)
        }</span>
        <span class="cov0" title="0">if len(args) &lt; 1 || len(words) &lt; 1 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">mark, name := words[wordCnt-1], args[0]
        if mark == name </span><span class="cov0" title="0">{
                name = meta.Bin
        }</span>
        <span class="cov0" title="0">if x := Invalid(err, mark, name, words...); x != "" </span><span class="cov0" title="0">{
                return x
        }</span>
        <span class="cov0" title="0">if x := unknown(name, words...); x != "" </span><span class="cov0" title="0">{
                return x
        }</span>
        <span class="cov0" title="0">if errors.Is(err, ErrCmd) </span><span class="cov0" title="0">{
                mark = strings.Join(args[1:], " ")
                return Hint(ErrCmd, mark+" --help")
        }</span>
        <span class="cov0" title="0">return Sprint(err)</span>
}

func Invalid(err error, mark, name string, words ...string) string <span class="cov8" title="1">{
        const req = 2
        if len(words) &lt; req </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov0" title="0">problem := strings.Join(words[0:2], " ")
        switch problem </span>{
        case flagSyntax:<span class="cov0" title="0">
                return SprintFlag(err, name, mark)</span>
        case flagRequired:<span class="cov0" title="0"> // retrotxt config shell
                return SprintCmd(ErrFlagNil, mark)</span>
        case flagChoice:<span class="cov0" title="0">
                return "flagChoice placeholder"</span>
        case invalidFlag:<span class="cov0" title="0"> // retroxt config shell -i
                return SprintFlag(ErrNotNil, name, mark)</span>
        case invalidType:<span class="cov0" title="0"> // retroxt --help=foo
                const minimum = 6
                if len(words) &gt;= minimum </span><span class="cov0" title="0">{
                        mark = strings.Join(words[4:6], " ")
                }</span>
                <span class="cov0" title="0">return parseType(name, mark, err)</span>
        case invalidSlice:<span class="cov0" title="0">
                return "invalidSlice placeholder"</span>
        case invalidCommand:<span class="cov0" title="0"> // retrotxt config foo
                return Hint(ErrCmd, mark+" --help")</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func unknown(name string, words ...string) string <span class="cov0" title="0">{
        const req = 2
        if len(words) &lt; req </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">const (
                unknownCmd   = "unknown command"
                unknownFlag  = "unknown flag:"
                unknownShort = "unknown shorthand"
                rt           = meta.Bin
        )
        problem := strings.Join(words[0:2], " ")
        switch problem </span>{
        case unknownCmd:<span class="cov0" title="0"> // retrotxt foo
                return Hint(fmt.Errorf("%w: %s", ErrCmd, words[2]), "--help")</span>
        case unknownFlag:<span class="cov0" title="0"> // retrotxt --foo
                mark := words[2]
                if mark == name </span><span class="cov0" title="0">{
                        name = rt
                }</span>
                <span class="cov0" title="0">return SprintFlag(ErrFlag, name, mark)</span>
        case unknownShort:<span class="cov0" title="0"> // retrotxt -foo
                mark := words[5]
                if mark == name </span><span class="cov0" title="0">{
                        name = rt
                }</span>
                <span class="cov0" title="0">return SprintFlag(ErrFlag, name, mark)</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func parseType(name, flag string, err error) string <span class="cov0" title="0">{
        const (
                invalidBool = "strconv.ParseBool"
                invalidInt  = "strconv.ParseInt"
                invalidStr  = "strconv.Atoi"
        )
        s := err.Error()
        switch </span>{
        case strings.Contains(s, invalidBool):<span class="cov0" title="0">
                return SprintFlag(ErrNotBool, name, flag)</span>
        case strings.Contains(s, invalidInt):<span class="cov0" title="0">
                return SprintFlag(ErrNotInt, name, flag)</span>
        case strings.Contains(s, invalidStr):<span class="cov0" title="0">
                return SprintFlag(ErrNotInts, name, flag)</span>
        default:<span class="cov0" title="0">
                return SprintFlag(err, name, flag)</span>
        }
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Package logs handles the formatting and returning of errors.
package logs

import (
        "fmt"
        "log"
        "os"
        "strings"

        "github.com/bengarrett/retrotxtgo/meta"
        "github.com/bengarrett/retrotxtgo/term"
)

const OSErr = 1 // OSErr is the operating system exit code for a program error.

// Fatal prints the error to stderr and exits.
func Fatal(err error) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">const panicing = false
        switch panicing </span>{
        case true:<span class="cov0" title="0">
                log.Printf("error type: %T\tmsg: %v\n", err, err)
                log.Panic(err)</span>
        default:<span class="cov0" title="0">
                fmt.Fprintln(os.Stderr, Sprint(err))
                os.Exit(OSErr)</span>
        }
}

// FatalS highlights the string and errors then exits.
func FatalS(err, wrap error, s string) <span class="cov0" title="0">{
        fmt.Fprintln(os.Stderr, SprintS(err, wrap, s))
        os.Exit(OSErr)
}</span>

// Hint returns a formatted error with a usage suggestion or hint.
// If s is empty then just the error is formatted.
func Hint(err error, s string) string <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if s == "" </span><span class="cov0" title="0">{
                return Sprint(err)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s\n run %s",
                Sprint(err), term.Example(fmt.Sprintf("%s %s", meta.Bin, s)))</span>
}

// Sprint formats and returns the error.
func Sprint(err error) string <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">elms, seps := strings.Split(err.Error(), ";"), []string{}
        for _, elm := range elms </span><span class="cov8" title="1">{
                if elm == "" || elm == "&lt;nil&gt;" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">seps = append(seps, elm)</span>
        }
        <span class="cov8" title="1">return fmt.Sprintf("%s%s.", term.Alert(), strings.Join(seps, ".\n"))</span>
}

// SprintCmd returns the command does not exist.
func SprintCmd(err error, cmd string) string <span class="cov8" title="1">{
        if cmd == "" || err == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s the command %s does not exist, %s",
                term.Alert(), cmd, err)</span>
}

// SprintFlag returns a problem with the flag.
func SprintFlag(err error, cmd, flag string) string <span class="cov8" title="1">{
        if cmd == "" || err == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">alert, toggle := term.Alert(), "--"
        if strings.Contains(flag, "-") </span><span class="cov0" title="0">{
                toggle = ""
        }</span> else<span class="cov8" title="1"> if len(flag) == 1 </span><span class="cov0" title="0">{
                toggle = "-"
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s with the %s %s%s flag, %s",
                alert, cmd, toggle, flag, err)</span>
}

// SprintS highlights the string and errors then exits.
func SprintS(err, wrap error, s string) string <span class="cov8" title="1">{
        if s == "" || err == nil || wrap == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s %s %q: %s",
                term.Alert(), term.Fuzzy(fmt.Sprintf("%v", err)), s,
                term.Fuzzy(fmt.Sprintf("%v", wrap)))</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package main

import (
        "fmt"
        "os"

        "github.com/bengarrett/retrotxtgo/cmd"
        "github.com/bengarrett/retrotxtgo/logs"
        "github.com/bengarrett/retrotxtgo/meta"
)

// goreleaser generated ldflags containers.
// https://goreleaser.com/cookbooks/using-main.version
var (
        version = meta.GoBuild
        commit  = meta.Placeholder
        date    = meta.Placeholder
        builtBy = "go builder"
)

func main() <span class="cov0" title="0">{
        meta.App.Version = version
        meta.App.Commit = commit
        meta.App.Date = date
        meta.App.BuiltBy = builtBy
        if err := cmd.Execute(); err != nil </span><span class="cov0" title="0">{
                if s := logs.Execute(err, false); s != "" </span><span class="cov0" title="0">{
                        fmt.Fprintln(os.Stderr, s)
                        os.Exit(logs.OSErr)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Package meta handles the metadata generated through the go builder using ldflags.
package meta

import (
        "fmt"
        "regexp"
        "strconv"
        "strings"
)

// Release metadata.
type Release struct {
        // Version of this program.
        Version string
        // GitHub commit checksum.
        Commit string
        // Date in the RFC3339 format.
        Date string
        // Built by name (goreleaser).
        BuiltBy string
}

// Version using semantic syntax values.
type Version struct {
        Major int // Major for incompatible API changes.
        Minor int // Minor for functionality in a backwards compatible manner.
        Patch int // Patch for backwards compatible bug fixes.
}

// App contains the version release and build metadata.
var App = Release{}

const (
        // Alpha Greek character.
        Alpha = ""
        // Beta Greek character.
        Beta = ""
        // GoBuild version when no ldflags are in use.
        GoBuild = "0.0.0"
        // Placeholder string when no ldflags are in use.
        Placeholder = "unset"
        // Bin is the binary filename of this program.
        Bin = "retrotxt"
        // Dir is the sub-directory name used for configuration and temporary paths.
        Dir = "retrotxt"
        // Name of this program.
        Name = "Retrotxt"
        // URL for this program's website.
        URL = "https://retrotxt.com/go"
        // Copyright  year range.
        Copyright = "2020-25"
)

// String returns the release version string.
func String() string <span class="cov8" title="1">{
        return Semantic(App.Version).String()
}</span>

// Semantic breaks down a semantic version string into major, minor and patch integers.
func Semantic(ver string) Version <span class="cov8" title="1">{
        invalid := Version{-1, -1, -1}
        if ver == "" </span><span class="cov8" title="1">{
                return invalid
        }</span>
        <span class="cov8" title="1">vers, nums := strings.Split(ver, "."), [3]int{}
        for i, v := range vers </span><span class="cov8" title="1">{
                if v == "" </span><span class="cov0" title="0">{
                        v = "0"
                }</span>
                <span class="cov8" title="1">num, err := strconv.Atoi(Digits(v))
                if err != nil </span><span class="cov8" title="1">{
                        return invalid
                }</span>
                <span class="cov8" title="1">nums[i] = num</span>
        }
        <span class="cov8" title="1">return Version{
                Major: nums[0],
                Minor: nums[1],
                Patch: nums[2],
        }</span>
}

// Digits returns only the digits and decimal point values from a string.
func Digits(s string) string <span class="cov8" title="1">{
        r := regexp.MustCompile("[^0-9/.]+")
        return r.ReplaceAllString(s, "")
}</span>

// String returns the semantic version string.
// If the version is invalid, it returns a placeholder, unset string.
func (v Version) String() string <span class="cov8" title="1">{
        if !v.Valid() </span><span class="cov8" title="1">{
                return Placeholder
        }</span>
        <span class="cov8" title="1">p := ""
        switch </span>{
        case v.Major == 0 &amp;&amp; v.Minor == 0 &amp;&amp; v.Patch == 0:<span class="cov8" title="1">
                p = "x"</span>
        case v.Major == 0 &amp;&amp; v.Minor == 0:<span class="cov8" title="1">
                p = Alpha</span>
        case v.Major == 0:<span class="cov8" title="1">
                p = Beta</span>
        }
        <span class="cov8" title="1">return fmt.Sprintf("%s%d.%d.%d", p, v.Major, v.Minor, v.Patch)</span>
}

// Valid reports whether the sematic versioning values are valid.
// Values that are less than zero are considered invalid.
func (v Version) Valid() bool <span class="cov8" title="1">{
        if v.Major &lt; 0 &amp;&amp; v.Minor &lt; 0 &amp;&amp; v.Patch &lt; 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Package nl provides line break characters for multiple system and microcomputer platforms.
package nl

import (
        "bufio"
        "bytes"
        "errors"
        "fmt"
        "io"
        "os"
        "strings"
)

var ErrReader = errors.New("the r reader cannot be nil")

// Common ASCII and EBCDIC control codes for new lines.
const (
        LF  rune = 10  // LF is the control code for a line feed.
        CR  rune = 13  // CR is the control code for a carriage return.
        NL  rune = 21  // NL is the control code for a new line, an EBCDIC control.
        NEL rune = 133 // NEL is the control code for a next line.
)

// LineBreak contains details on the line break sequence used to create a new line in a text file.
type LineBreak struct {
        Abbr    string  `json:"string"  xml:"string,attr"` // Abbr is the abbreviation for the line break.
        Escape  string  `json:"escape"  xml:"-"`           // Escape is the escape sequence for the line break.
        Decimal [2]rune `json:"decimal" xml:"decimal"`     // Decimal is the numeric character code for the line break.
}

// Find determines the new lines characters found in the rune pair.
func (lb *LineBreak) Find(r [2]rune) <span class="cov8" title="1">{
        a, e := "", ""
        switch r </span>{
        case [2]rune{LF}:<span class="cov8" title="1">
                a = "lf"
                e = "\n"</span>
        case [2]rune{CR}:<span class="cov0" title="0">
                a = "cr"
                e = "\r"</span>
        case [2]rune{CR, LF}:<span class="cov8" title="1">
                a = "crlf"
                e = "\r\n"</span>
        case [2]rune{LF, CR}:<span class="cov0" title="0">
                a = "lfcr"
                e = "\n\r"</span>
        case [2]rune{NL}, [2]rune{NEL}:<span class="cov0" title="0">
                a = "nl"
                e = "\025"</span>
        }
        <span class="cov8" title="1">lb.Decimal = r
        lb.Abbr = strings.ToUpper(a)
        lb.Escape = e</span>
}

// Total counts the number of lines in the named file
// based on the provided line break sequence.
func (lb *LineBreak) Total(name string) (int, error) <span class="cov8" title="1">{
        r, err := os.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">defer r.Close()
        lines, err := Lines(r, lb.Decimal)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return lines, nil</span>
}

// Lines counts the number of lines in the interface.
// The lb rune pair is the line break sequence.
// If the line break only has one rune, then the second rune should be 0.
func Lines(r io.Reader, lb [2]rune) (int, error) <span class="cov8" title="1">{
        if r == nil </span><span class="cov0" title="0">{
                return 0, ErrReader
        }</span>
        <span class="cov8" title="1">lineBreak := []byte{byte(lb[0]), byte(lb[1])}
        if lb[1] == 0 </span><span class="cov8" title="1">{
                lineBreak = []byte{byte(lb[0])}
        }</span>
        <span class="cov8" title="1">p, count := make([]byte, bufio.MaxScanTokenSize), 0
        for </span><span class="cov8" title="1">{
                size, err := r.Read(p)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("lines could not read buffer: %w", err)
                }</span>
                <span class="cov8" title="1">pos := 0
                for </span><span class="cov8" title="1">{
                        i := bytes.Index(p[pos:], lineBreak)
                        if size == pos </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">if i == -1 </span><span class="cov8" title="1">{
                                if size == 0 </span><span class="cov0" title="0">{
                                        return 0, nil // empty file
                                }</span>
                                <span class="cov8" title="1">if count == 0 </span><span class="cov8" title="1">{
                                        return 1, nil // no line breaks = 1 line
                                }</span>
                                <span class="cov8" title="1">count++
                                return count, nil</span>
                        }
                        <span class="cov8" title="1">pos += i + 1
                        count++</span>
                }
                <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return count, nil</span>
}

// System is a micro or computer platform.
type System int

const (
        Host      System = iota // Host is the host operating system default.
        Acorn                   // Acorn is the Acorn Archimedes.
        Amiga                   // Amiga is the Commodore Amiga.
        Commodore               // Commodore is the Commodore 64 and compatibles.
        Darwin                  // Darwin is Apple macOS.
        Linux                   // Linux is the Linux operating system.
        Macintosh               // Macintosh is the Apple Macintosh.
        PCDos                   // PCDos is an IBM PC and Microsoft DOS and compatibles.
        Unix                    // Unix are both Unix and BSD.
        Windows                 // Windows is Microsoft Windows.
)

// NewLine returns a new line or line break characters for the system platform.
func NewLine(s System) string <span class="cov8" title="1">{
        switch s </span>{
        case PCDos, Windows:<span class="cov8" title="1">
                return string(CR) + string(LF)</span>
        case Commodore, Darwin, Macintosh:<span class="cov8" title="1">
                return string(CR)</span>
        case Amiga, Linux, Unix:<span class="cov8" title="1">
                return string(LF)</span>
        case Acorn:<span class="cov0" title="0">
                return string(LF) + string(CR)</span>
        case Host:<span class="cov0" title="0">
                return "\n"</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Package sample opens and encodes the example embedded text files.
// These files are used for demonstrating the info and the view commands.
package sample

import (
        "embed"
        "errors"
        "fmt"
        "os"
        "strings"

        "github.com/bengarrett/retrotxtgo/convert"
        "github.com/bengarrett/retrotxtgo/meta"
        "golang.org/x/text/encoding"
        "golang.org/x/text/encoding/charmap"
        "golang.org/x/text/encoding/japanese"
        "golang.org/x/text/encoding/unicode"
        "golang.org/x/text/encoding/unicode/utf32"
)

var (
        ErrEncode   = errors.New("no encoding provided")
        ErrConvert  = errors.New("unknown convert method")
        ErrConvNil  = errors.New("conv argument cannot be empty")
        ErrName     = errors.New("sample filename does not exist")
        ErrNotFound = errors.New("internal embed file is not found")
)

// File is the embedded file system with all the static files.
//
//go:embed ansi/*.ans plaintext/*.txt plaintext/*.asc
var File embed.FS

// ANSI is the embedded file system with the ansi subdirectory.
//
//go:embed ansi/*.ans ansi/*.utf8ans
var ANSI embed.FS

// PlainText is the embedded file system with the text subdirectory.
//
//go:embed plaintext/*.txt plaintext/*.asc
var PlainText embed.FS

// Flags and configuration values by the user.
type Flags struct {
        Input    encoding.Encoding // Input encoding is set using the input flag.
        Original bool              // Original encoding is set using the original flag.
}

// Sample textfile data.
type Sample struct {
        // the order of these fields must not be changed
        Convert     Output            // Convert text method.
        Encoding    encoding.Encoding // Encoding used by the sample.
        Name        string            // Name of the sample.
        Description string            // Description of the sample.
}

// Output method for the embedded text files.
type Output int

const (
        Ansi Output = iota // should only be use with ANSI text
        Ctrl               // print the common text control codes as characters
        Text               // obeys the common text controls
        Dump               // obeys the common text controls except for EOF, end-of-file
)

// Map is the collection of sample text files.
// Each sample includes the output method, character encoding,
// the filename and a brief description.
func Map() map[string]Sample <span class="cov8" title="1">{
        var (
                cp037  = charmap.CodePage037
                cp437  = charmap.CodePage437
                cp865  = charmap.CodePage865 // ibm865
                cp1252 = charmap.Windows1252 // cp1252
                iso1   = charmap.ISO8859_1   // 1
                iso15  = charmap.ISO8859_15  // 15
                jis    = japanese.ShiftJIS   // shiftjis
                u8     = unicode.UTF8
                u8bom  = unicode.UTF8BOM
                u16    = unicode.UTF16(unicode.LittleEndian, unicode.IgnoreBOM)
                u16be  = unicode.UTF16(unicode.BigEndian, unicode.UseBOM)
                u16le  = unicode.UTF16(unicode.LittleEndian, unicode.UseBOM)
                u32    = utf32.UTF32(utf32.LittleEndian, utf32.IgnoreBOM)
                u32be  = utf32.UTF32(utf32.BigEndian, utf32.UseBOM)
                u32le  = utf32.UTF32(utf32.LittleEndian, utf32.UseBOM)
        )
        m := map[string]Sample{
                "037":           {Text, cp037, "plaintext/cp037.txt", "EBCDIC 037 IBM mainframe test"},
                "437":           {Dump, cp437, "plaintext/cp437-crlf.txt", "CP-437 all characters test using Windows line breaks"},
                "437.cr":        {Dump, cp437, "plaintext/cp437-cr.txt", "CP-437 all characters test using CR (carriage return)"},
                "437.lf":        {Dump, cp437, "plaintext/cp437-lf.txt", "CP-437 all characters test using LF (line feed)"},
                "865":           {Text, cp865, "plaintext/cp865.txt", "CP-865 and CP-860 Nordic test"},
                "1252":          {Text, cp1252, "plaintext/cp1252.txt", "Windows-1252 English test"},
                "ascii":         {Text, cp437, "plaintext/retrotxt.asc", meta.Name + " ASCII logos"},
                "ansi":          {Ansi, cp437, "ansi/retrotxt.ans", meta.Name + " 256 color ANSI logo"},
                "ansi.aix":      {Ansi, cp437, "ansi/ansi-aixterm.ans", "IBM AIX terminal colors"},
                "ansi.blank":    {Ansi, cp437, "ansi/ansi-blank.ans", "Empty file test"},
                "ansi.cp":       {Ansi, cp437, "ansi/ansi-cp.ans", "ANSI cursor position tests"},
                "ansi.cpf":      {Ansi, cp437, "ansi/ansi-cpf.ans", "ANSI cursor forward tests"},
                "ansi.hvp":      {Ansi, cp437, "ansi/ansi-hvp.ans", "ANSI horizontal and vertical cursor positioning"},
                "ansi.proof":    {Ansi, cp437, "ansi/ansi-proof.ans", "ANSI formatting proof sheet"},
                "ansi.rgb":      {Ansi, cp437, "ansi/ansi-rgb.ans", "ANSI RGB 24-bit color sheet"},
                "ansi.setmodes": {Ansi, cp437, "ansi/ansi-setmodes.ans", "MS-DOS ANSI.SYS Set Mode examples"},
                "iso-1":         {Text, iso1, "plaintext/iso-8859-1.txt", "ISO 8859-1 select characters"},
                "iso-15":        {Text, iso15, "plaintext/iso-8859-15.txt", "ISO 8859-15 select characters"},
                "sauce":         {Dump, cp437, "plaintext/sauce.txt", "SAUCE metadata test"},
                "shiftjis":      {Text, jis, "plaintext/shiftjis.txt", "Shift-JIS and Mona font test"},
                "us-ascii":      {Dump, u8, "plaintext/us-ascii.txt", "US-ASCII controls test"},
                "utf8":          {Text, u8, "plaintext/utf-8.txt", "UTF-8 test with no Byte Order Mark"},
                "utf8.bom":      {Text, u8bom, "plaintext/utf-8-bom.txt", "UTF-8 test with a Byte Order Mark"},
                "utf16":         {Text, u16, "plaintext/utf-16.txt", "UTF-16 test"},
                "utf16.be":      {Text, u16be, "plaintext/utf-16-be.txt", "UTF-16 Big Endian test"},
                "utf16.le":      {Text, u16le, "plaintext/utf-16-le.txt", "UTF-16 Little Endian test"},
                "utf32":         {Text, u32, "plaintext/utf-32.txt", "UTF-32 test"},
                "utf32.be":      {Text, u32be, "plaintext/utf-32-be.txt", "UTF-32 Big Endian test"},
                "utf32.le":      {Text, u32le, "plaintext/utf-32-le.txt", "UTF-32 Little Endian test"},
        }
        return m
}</span>

// Open the named sample text file.
// The byte array is encoded using the original character encoding.
func Open(name string) ([]byte, error) <span class="cov8" title="1">{
        name = strings.ToLower(name)
        samp, exist := Map()[name]
        if !exist </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: %w", name, ErrName)
        }</span>
        <span class="cov8" title="1">b, err := File.ReadFile(samp.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open sample %q: %w", samp.Name, err)
        }</span>
        <span class="cov8" title="1">return b, nil</span>
}

// Transform the byte array to use the supplied character encoding.
func Transform(e encoding.Encoding, b ...byte) ([]byte, error) <span class="cov8" title="1">{
        if e == nil </span><span class="cov8" title="1">{
                return nil, ErrEncode
        }</span>
        <span class="cov8" title="1">p, err := e.NewEncoder().Bytes(b)
        if err != nil </span><span class="cov0" title="0">{
                if len(p) == 0 </span><span class="cov0" title="0">{
                        return b, fmt.Errorf("encoder could not convert bytes to %s: %w", e, err)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("%s: %w", e, err)</span>
        }
        <span class="cov8" title="1">return p, nil</span>
}

// Open and convert the named sample text file into Unicode runes.
// Use the other open function to return the raw bytes in their original encoding.
func (flag Flags) Open(conv *convert.Convert, name string) ([]rune, error) <span class="cov8" title="1">{
        name = strings.ToLower(name)
        if _, err := os.Stat(name); !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">samp, exist := Map()[name]
        if !exist </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%s: %w", name, ErrName)
        }</span>
        <span class="cov8" title="1">b, err := File.ReadFile(samp.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open sample %q: %w", samp.Name, err)
        }</span>
        <span class="cov8" title="1">if conv == nil </span><span class="cov8" title="1">{
                return nil, ErrConvNil
        }</span>
        <span class="cov8" title="1">conv.Input.Encoding = flag.Input
        if conv.Input.Encoding == nil </span><span class="cov8" title="1">{
                conv.Input.Encoding = samp.Encoding
        }</span>
        // override "control" flag values for code page table samples
        <span class="cov8" title="1">ignoreCtrls := false
        switch name </span>{
        case "437", "437.cr", "437.lf":<span class="cov8" title="1">
                ignoreCtrls = true</span>
        default:<span class="cov8" title="1"></span>
        }
        <span class="cov8" title="1">if ignoreCtrls </span><span class="cov8" title="1">{
                conv.Args.Controls = []string{}
        }</span>
        <span class="cov8" title="1">r, err := samp.transform(conv, b...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

func (samp *Sample) transform(conv *convert.Convert, b ...byte) ([]rune, error) <span class="cov8" title="1">{
        switch samp.Convert </span>{
        case Ansi:<span class="cov0" title="0">
                return conv.ANSI(b...)</span>
        case Ctrl:<span class="cov0" title="0">
                return conv.Chars(b...)</span>
        case Dump:<span class="cov8" title="1">
                return conv.Dump(b...)</span>
        case Text:<span class="cov8" title="1">
                return conv.Text(b...)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("transform sample %q: %w", samp.Convert, ErrConvert)</span>
        }
}

// Valid reports whether the named sample text file exists.
func Valid(name string) bool <span class="cov8" title="1">{
        if _, exist := Map()[name]; !exist </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package table

import (
        "fmt"
        "io"
        "text/tabwriter"

        "github.com/bengarrett/retrotxtgo/term"
        "github.com/bengarrett/retrotxtgo/xud"
        "golang.org/x/text/encoding"
        "golang.org/x/text/encoding/charmap"
        "golang.org/x/text/encoding/japanese"
        "golang.org/x/text/encoding/traditionalchinese"
        "golang.org/x/text/encoding/unicode"
        "golang.org/x/text/encoding/unicode/utf32"
)

// Lang describes the common natural language uses of the encoding.
type Lang map[encoding.Encoding]string

// Languages returns a list of code page encodings and their target natural languages.
func Languages() *Lang <span class="cov8" title="1">{
        lang := Lang{
                charmap.CodePage037:     "US English",
                charmap.CodePage437:     "US English",
                charmap.CodePage850:     "West Europe",
                charmap.CodePage852:     "Central Europe Latin script",
                charmap.CodePage855:     "Central Europe Cyrillic script",
                charmap.CodePage858:     "West Europe, includes the  symbol",
                charmap.CodePage860:     "Portuguese",
                charmap.CodePage862:     "Hebrew",
                charmap.CodePage863:     "French Canadian",
                charmap.CodePage865:     "Danish, Norwegian",
                charmap.CodePage866:     "USSR Cyrillic script",
                charmap.CodePage1047:    "West Europe",
                charmap.CodePage1140:    "US English",
                charmap.ISO8859_1:       "West Europe",
                charmap.ISO8859_2:       "Central Europe Latin script",
                charmap.ISO8859_3:       "Esperanto, Maltese, Turkish",
                charmap.ISO8859_4:       "Estonian, Latvian, Lithuanian, Greenlandic, Smi",
                charmap.ISO8859_5:       "Russian Cyrillic script",
                charmap.ISO8859_6:       "Arabic",
                charmap.ISO8859_6E:      "Arabic",
                charmap.ISO8859_6I:      "Arabic",
                charmap.ISO8859_7:       "Greek",
                charmap.ISO8859_8:       "Hebrew",
                charmap.ISO8859_8E:      "Hebrew",
                charmap.ISO8859_8I:      "Hebrew",
                charmap.ISO8859_9:       "Turkish",
                charmap.ISO8859_10:      "Nordic languages",
                xud.XUserDefinedISO11:   "Thai", // ISO-8859-11
                charmap.ISO8859_13:      "Baltic languages",
                charmap.ISO8859_14:      "Celtic languages",
                charmap.ISO8859_15:      "West Europe, includes the  symbol",
                charmap.ISO8859_16:      "Gaj's Latin alphabet for European languages",
                charmap.KOI8R:           "Russian, Bulgarian",
                charmap.KOI8U:           "Ukrainian",
                charmap.Macintosh:       "West Europe",
                charmap.Windows874:      "Thai",
                charmap.Windows1250:     "Central Europe Latin script",
                charmap.Windows1251:     "Cyrillic script",
                charmap.Windows1252:     "English and West Europe",
                charmap.Windows1253:     "Greek",
                charmap.Windows1254:     "Turkish",
                charmap.Windows1255:     "Hebrew",
                charmap.Windows1256:     "Arabic",
                charmap.Windows1257:     "Estonian, Latvian, Lithuanian",
                charmap.Windows1258:     "Vietnamese",
                japanese.ShiftJIS:       "Japanese",
                traditionalchinese.Big5: "Traditional Chinese",
                unicode.UTF8:            "Unicode, all major languages",
                xud.XUserDefined1963:    "US English",
                xud.XUserDefined1965:    "US English",
                xud.XUserDefined1967:    "US English",
        }
        return &amp;lang
}</span>

// Language returns the natural language usage of the encoding.
func Language(e encoding.Encoding) string <span class="cov8" title="1">{
        l := *Languages()
        return l[e]
}</span>

// ListLanguage writes a tabled list of supported IANA character set encodings
// and the languages they target.
func ListLanguage(wr io.Writer) error <span class="cov8" title="1">{
        if wr == nil </span><span class="cov0" title="0">{
                wr = io.Discard
        }</span>
        <span class="cov8" title="1">const header, title = " Formal name\t Named value\t Language\t",
                " Known legacy code pages and their target languages, regions, or alphabets "
        const padding, width = 2, 76
        w := tabwriter.NewWriter(wr, 0, 0, padding, ' ', 0)
        term.Head(wr, width, title)
        fmt.Fprintf(w, "\n%s\n", header)
        x := Charmaps()
        x = append(x,
                xud.XUserDefined1963,
                xud.XUserDefined1965,
                xud.XUserDefined1967)
        for _, e := range x </span><span class="cov8" title="1">{
                switch e </span>{
                case charmap.XUserDefined:<span class="cov8" title="1">
                        continue</span>
                case charmap.ISO8859_10:<span class="cov8" title="1">
                        c, err := Rows(e)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%q: %w", e, err)
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintf(w, " %s\t %s\t %s\t\n",
                                c.Name, c.Value, Language(e))
                        // intentionally insert ISO-8895-11 after 10.
                        x := xud.XUserDefinedISO11
                        fmt.Fprintf(w, " %s\t %s\t %s\t\n",
                                x, xud.Name(x), Language(x))
                        continue</span>
                case
                        unicode.UTF16(unicode.BigEndian, unicode.UseBOM),
                        unicode.UTF16(unicode.BigEndian, unicode.IgnoreBOM),
                        unicode.UTF16(unicode.LittleEndian, unicode.IgnoreBOM),
                        utf32.UTF32(utf32.BigEndian, utf32.UseBOM),
                        utf32.UTF32(utf32.BigEndian, utf32.IgnoreBOM),
                        utf32.UTF32(utf32.LittleEndian, utf32.IgnoreBOM):<span class="cov8" title="1">
                        continue</span>
                }
                <span class="cov8" title="1">c, err := Rows(e)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%q: %w", e, err)
                }</span>
                // do not use ANSI colors in cells as it will break the table layout
                <span class="cov8" title="1">fmt.Fprintf(w, " %s\t %s\t %s\t\n",
                        c.Name, c.Value, Language(e))</span>
        }
        <span class="cov8" title="1">return w.Flush()</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package table

import (
        "fmt"
        "io"
        "strconv"
        "strings"
        "text/tabwriter"

        "github.com/bengarrett/retrotxtgo/meta"
        "github.com/bengarrett/retrotxtgo/term"
        "github.com/bengarrett/retrotxtgo/xud"
        "golang.org/x/text/encoding"
        "golang.org/x/text/encoding/charmap"
        "golang.org/x/text/encoding/htmlindex"
        "golang.org/x/text/encoding/ianaindex"
        "golang.org/x/text/encoding/japanese"
        "golang.org/x/text/encoding/traditionalchinese"
        "golang.org/x/text/encoding/unicode"
        "golang.org/x/text/encoding/unicode/utf32"
)

const latin = "isolatin"

// Row is an item for the list of code pages.
type Row struct {
        Name    string // Name is the formal name of the character encoding.
        Value   string // Value is the short name of the character encoding.
        Numeric string // Numeric is an optional, shorter numeric value of the character encoding.
        Alias   string // Alias is an optional, informal but common use value of the character encoding.
}

// Charmaps returns all the supported legacy text encodings.
func Charmaps() []encoding.Encoding <span class="cov8" title="1">{
        e := []encoding.Encoding{}
        // create a collection of all the encodings
        a := charmap.All
        a = append(a, japanese.All...)
        a = append(a, traditionalchinese.All...)
        a = append(a, unicode.All...)
        a = append(a, utf32.All...)
        // iterate the collection and skip the unwanted and duplicate encodings
        for _, m := range a </span><span class="cov8" title="1">{
                switch m </span>{
                case japanese.EUCJP,
                        japanese.ISO2022JP,
                        charmap.MacintoshCyrillic:<span class="cov8" title="1">
                        continue</span>
                }
                <span class="cov8" title="1">e = append(e, m)</span>
        }
        <span class="cov8" title="1">return e</span>
}

// List returns a tabled list of supported IANA character set encodings.
func List(wr io.Writer) error <span class="cov8" title="1">{ //nolint:funlen
        if wr == nil </span><span class="cov0" title="0">{
                wr = io.Discard
        }</span>
        <span class="cov8" title="1">const header, title = " Formal name\t Named value\t Numeric value\t Alias value\t",
                " Known legacy code pages and character encodings "
        const verticalBars = tabwriter.Debug
        const padding, width = 2, 76
        w := tabwriter.NewWriter(wr, 0, 0, padding, ' ', verticalBars)
        term.Head(w, width, title)
        fmt.Fprintf(w, "\n%s\n", header)
        x := Charmaps()
        x = append(x, xud.XUserDefined1963, xud.XUserDefined1965, xud.XUserDefined1967)
        for _, e := range x </span><span class="cov8" title="1">{
                if e == charmap.XUserDefined </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">c, err := Rows(e)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">switch e </span>{
                case charmap.ISO8859_10:<span class="cov8" title="1">
                        fmt.Fprintf(w, " %s\t %s\t %s\t %s\t\n",
                                c.Name, c.Value, c.Numeric, c.Alias)
                        // intentionally insert ISO-8895-11 after 10.
                        x := xud.XUserDefinedISO11
                        fmt.Fprintf(w, " %s\t %s\t %s\t %s\t\n",
                                x, xud.Name(x), xud.Numeric(x), xud.Alias(x))
                        continue</span>
                case charmap.CodePage037, charmap.CodePage1047, charmap.CodePage1140:<span class="cov8" title="1">
                        fmt.Fprintf(w, " * %s\t %s\t %s\t %s\t\n",
                                c.Name, c.Value, c.Numeric, c.Alias)
                        continue</span>
                case
                        traditionalchinese.Big5,
                        unicode.UTF16(unicode.BigEndian, unicode.UseBOM),
                        unicode.UTF16(unicode.BigEndian, unicode.IgnoreBOM),
                        unicode.UTF16(unicode.LittleEndian, unicode.IgnoreBOM),
                        utf32.UTF32(utf32.BigEndian, utf32.UseBOM),
                        utf32.UTF32(utf32.BigEndian, utf32.IgnoreBOM),
                        utf32.UTF32(utf32.LittleEndian, utf32.IgnoreBOM):<span class="cov8" title="1">
                        fmt.Fprintf(w, "  %s\t %s\t %s\t %s\t\n",
                                c.Name, c.Value, c.Numeric, c.Alias)
                        continue</span>
                case xud.XUserDefined1963, xud.XUserDefined1965, xud.XUserDefined1967:<span class="cov8" title="1">
                        fmt.Fprintf(w, "  %s\t %s\t %s\t %s\t\n",
                                c.Name, c.Value, c.Numeric, c.Alias)
                        continue</span>
                }
                // do not use ANSI colors in cells as it will break the table layout
                <span class="cov8" title="1">fmt.Fprintf(w, " %s\t %s\t %s\t %s\t\n",
                        c.Name, c.Value, c.Numeric, c.Alias)</span>
        }
        <span class="cov8" title="1">fmt.Fprintln(w, "\n "+term.Info("*")+
                " An EBCDIC encoding found on IBM mainframes that is not ASCII compatible.")
        fmt.Fprintln(w, " "+term.Info("")+
                " Encoding is not usable with the "+term.Example("table")+" command.")
        fmt.Fprintln(w, " "+term.Info("")+
                " Encoding is only usable with the "+term.Example("table")+" command."+
                "\n   You can use the "+term.Example("table ascii")+" command to list all three X3.4 tables.")
        fmt.Fprintln(w, "\nEither named, numeric or alias values are valid code page arguments.")
        fmt.Fprintln(w, "  These values all match ISO 8859-1.")
        cmds := meta.Bin + " table "
        fmt.Fprintf(w, "  %s%s  %s\n",
                term.Example(cmds), term.Comment("iso-8859-1"), term.Fuzzy("# named"))
        fmt.Fprintf(w, "  %s%s           %s\n",
                term.Example(cmds), term.Comment("1"), term.Fuzzy("# numeric"))
        fmt.Fprintf(w, "  %s%s      %s\n",
                term.Example(cmds), term.Comment("latin1"), term.Fuzzy("# alias"))
        fmt.Fprintf(w, "\n  IBM Code Page 437 (%s) is commonly used on MS-DOS and ANSI art.\n",
                term.Comment("cp437"))
        fmt.Fprintf(w, "  ISO 8859-1 (%s) is found on historic Unix, Amiga and the early Internet.\n",
                term.Comment("latin1"))
        fmt.Fprintf(w, "  Windows 1252 (%s) is found on Windows ME/98 and earlier systems.\n",
                term.Comment("cp1252"))
        fmt.Fprintf(w, "  Macintosh (%s) is found on Mac OS 9 and earlier systems.\n",
                term.Comment("macintosh"))
        fmt.Fprintf(w, "\n%s, PCs and the web today use Unicode UTF-8. As a subset,\n", meta.Name)
        fmt.Fprintln(w, "UTF-8 is backwards compatible with US-ASCII. For example capital")
        fmt.Fprintln(w, "letter A is represented by the same byte value in both encodings.")
        return w.Flush()</span>
}

// Rows return character encoding details for use in a text table.
func Rows(e encoding.Encoding) (Row, error) <span class="cov8" title="1">{
        if e == nil </span><span class="cov8" title="1">{
                return Row{}, ErrNil
        }</span>
        <span class="cov8" title="1">r := Row{
                Name: fmt.Sprint(e),
        }
        switch e </span>{
        case xud.XUserDefined1963, xud.XUserDefined1965, xud.XUserDefined1967:<span class="cov8" title="1">
                r.Value = xud.Name(e)
                r.Numeric = xud.Numeric(e)
                r.Alias = xud.Alias(e)
                return r, nil</span>
        }
        <span class="cov8" title="1">var err error
        if r.Value, err = htmlindex.Name(e); err != nil </span><span class="cov8" title="1">{
                r.Value, err = ianaindex.MIME.Name(e)
                if err != nil </span><span class="cov0" title="0">{
                        return Row{}, err
                }</span>
        } else<span class="cov8" title="1"> {
                r.Alias, err = ianaindex.MIME.Name(e)
                if err != nil </span><span class="cov0" title="0">{
                        return Row{}, err
                }</span>
        }
        <span class="cov8" title="1">r.Value = strings.ToLower(Uniform(r.Value))
        if i := Numeric(r.Name); i &gt; -1 </span><span class="cov8" title="1">{
                r.Numeric = strconv.Itoa(i)
        }</span>
        <span class="cov8" title="1">r.Alias, err = Alias(r.Alias, r.Value, e)
        if err != nil </span><span class="cov0" title="0">{
                return Row{}, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

// Numeric returns a numeric alias for a character encoding.
// A -1 int is returned whenever an alias could not be generated.
// Unicode based encodings always return -1.
func Numeric(name string) int <span class="cov8" title="1">{
        name = strings.ToLower(name)
        if strings.Contains(name, "utf") </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">s1, s2 := strings.Split(name, " "), strings.Split(name, "-")
        if len(s1) &lt; 1 || len(s2) &lt; 1 </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov8" title="1">if i, err := strconv.Atoi(s1[len(s1)-1]); err == nil </span><span class="cov8" title="1">{
                return i
        }</span>
        <span class="cov8" title="1">if i, err := strconv.Atoi(s2[len(s2)-1]); err == nil </span><span class="cov8" title="1">{
                return i
        }</span>
        <span class="cov8" title="1">return -1</span>
}

// Alias returns an alias for a encoding.
// Only the alias argument is required.
func Alias(alias, value string, e encoding.Encoding) (string, error) <span class="cov8" title="1">{
        a := strings.ToLower(alias)
        if a == value </span><span class="cov8" title="1">{
                a = ""
        }</span>
        <span class="cov8" title="1">if a != "" </span><span class="cov8" title="1">{
                return a, nil
        }</span>
        <span class="cov8" title="1">if s := customValues(value); s != "" </span><span class="cov8" title="1">{
                return s, nil
        }</span>
        <span class="cov8" title="1">a, err := ianaindex.MIB.Name(e)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">a = strings.ToLower(a)
        if a == value </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if len(a) &gt; 2 &amp;&amp; a[:2] == "pc" </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if len(a) == 9 &amp;&amp; a[:8] == latin </span><span class="cov8" title="1">{
                return "latin" + a[8:], nil
        }</span>
        <span class="cov8" title="1">if len(a) &gt; 9 &amp;&amp; a[:8] == latin </span><span class="cov8" title="1">{
                return a[8:], nil
        }</span>
        <span class="cov8" title="1">return a, nil</span>
}

// customvalues for aliases can be added here.
func customValues(value string) string <span class="cov8" title="1">{
        switch value </span>{
        case "cp437":<span class="cov8" title="1">
                return "msdos"</span>
        case "cp850":<span class="cov8" title="1">
                return "latinI"</span>
        case "cp852":<span class="cov8" title="1">
                return "latinII"</span>
        case "macintosh":<span class="cov8" title="1">
                return "mac"</span>
        case "big5":<span class="cov8" title="1">
                return "big-5"</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

// Uniform formats MIME values.
func Uniform(mime string) string <span class="cov8" title="1">{
        const limit = 1
        s := mime
        s = strings.Replace(s, "IBM00", "CP", limit)
        s = strings.Replace(s, "IBM01", "CP1", limit)
        s = strings.Replace(s, "IBM", "CP", limit)
        s = strings.Replace(s, "windows-", "CP", limit)
        return s
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// Package table creates a table of all the characters in the named 8-bit character set.
package table

import (
        "errors"
        "fmt"
        "io"
        "math"
        "strings"
        "text/tabwriter"
        "unicode"

        "github.com/bengarrett/retrotxtgo/byter"
        "github.com/bengarrett/retrotxtgo/convert"
        "github.com/bengarrett/retrotxtgo/term"
        "github.com/bengarrett/retrotxtgo/xud"
        "github.com/gookit/color"
        "golang.org/x/text/encoding"
        "golang.org/x/text/encoding/charmap"
        "golang.org/x/text/encoding/japanese"
        "golang.org/x/text/encoding/traditionalchinese"
        uni "golang.org/x/text/encoding/unicode"
        "golang.org/x/text/encoding/unicode/utf32"
)

var (
        ErrNil   = errors.New("character encoding cannot be a nil value")
        ErrBig5  = errors.New("big5 table encodings are not supported")
        ErrUTF16 = errors.New("utf-16 table encodings are not supported")
        ErrUTF32 = errors.New("utf-32 table encodings are not supported")
)

const width = 68 // width of the table in characters.

// Table prints, aligns and formats to the writer all characters in the named 8-bit character set.
func Table(wr io.Writer, name string) error <span class="cov8" title="1">{ //nolint:funlen
        if wr == nil </span><span class="cov8" title="1">{
                wr = io.Discard
        }</span>
        <span class="cov8" title="1">if name == "" </span><span class="cov0" title="0">{
                return xud.ErrName
        }</span>
        <span class="cov8" title="1">cp := xud.CodePage(name)
        if cp == nil </span><span class="cov8" title="1">{
                var err error
                cp, err = CodePage(name)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">h := fmt.Sprintf("%s", cp)
        h += CharmapAlias(cp) + charmapStandard(cp)
        const tabWidth = 8
        w := tabwriter.NewWriter(wr, 0, tabWidth, 0, '\t', 0)
        term.Head(w, width, " "+h)
        columns(w)
        if x := swapper(name); x != nil </span><span class="cov0" title="0">{
                cp = x
        }</span>
        <span class="cov8" title="1">c := convert.Convert{}
        c.Input.Encoding = cp
        p := byter.MakeBytes()
        runes, err := c.Chars(p...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("table convert bytes error: %w", err)
        }</span>
        <span class="cov8" title="1">enc := reverter(name)
        const hex, maximum = 16, 255
        row := 0
out:
        for i, r := range runes </span><span class="cov8" title="1">{
                char := Character(enc, i, r)
                if x := Replacement(name, i); x != "" </span><span class="cov8" title="1">{
                        char = x
                }</span>
                <span class="cov8" title="1">switch </span>{
                case i == 0:<span class="cov8" title="1">
                        fmt.Fprintf(w, " %s %s %s %s",
                                color.OpFuzzy.Sprint("0"),
                                color.OpFuzzy.Sprint("|"),
                                char, color.OpFuzzy.Sprint("|"))</span>
                case i == maximum:<span class="cov8" title="1">
                        fmt.Fprintf(w, " %s %s\n", char,
                                color.OpFuzzy.Sprint("|"))</span>
                case math.Mod(float64(i+1), hex) == 0:<span class="cov8" title="1">
                        // every 16th loop
                        row++
                        if xud.Code7bit(enc) &amp;&amp; row &gt;= 8 </span><span class="cov0" title="0">{
                                // exit after the 7th row
                                fmt.Fprintf(w, " %s %s\n", char,
                                        color.OpFuzzy.Sprint("|"))
                                break out</span>
                        }
                        <span class="cov8" title="1">fmt.Fprintf(w, " %s %s\n %s %s", char,
                                color.OpFuzzy.Sprint("|"),
                                color.OpFuzzy.Sprintf("%X", row),
                                color.OpFuzzy.Sprint("|"))</span>
                default:<span class="cov8" title="1">
                        fmt.Fprintf(w, " %s %s", char,
                                color.OpFuzzy.Sprint("|"))</span>
                }
        }
        <span class="cov8" title="1">xud.Footnote(w, cp)
        Footnote(w, name)
        fmt.Fprint(w, "\n")
        return w.Flush()</span>
}

func columns(w io.Writer) <span class="cov8" title="1">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">const start, end = 0, 15
        for i := range 16 </span><span class="cov8" title="1">{
                switch i </span>{
                case start:<span class="cov8" title="1">
                        fmt.Fprintf(w, "%s", color.OpFuzzy.Sprintf("     %X  ", i))</span>
                case end:<span class="cov8" title="1">
                        fmt.Fprintf(w, "%s", color.OpFuzzy.Sprintf(" %X  \n", i))</span>
                default:<span class="cov8" title="1">
                        fmt.Fprintf(w, "%s", color.OpFuzzy.Sprintf(" %X  ", i))</span>
                }
        }
}

// Footnote writes a footnote with extra details or corrections for the named
// code page or encoding. It is called by Table.
func Footnote(w io.Writer, name string) <span class="cov8" title="1">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">if SHY173(name) </span><span class="cov0" title="0">{
                fmt.Fprintln(w)
                fmt.Fprintln(w, "* Cell A-D is SHY (soft hyphen), but it is not printable in Unicode.")
                return
        }</span>
        <span class="cov8" title="1">x, _ := CodePage(name)
        if SHY240(x) </span><span class="cov0" title="0">{
                fmt.Fprintln(w)
                fmt.Fprintln(w, "* Cell F-0 is SHY (soft hyphen), but it is not printable in Unicode.")
        }</span>
}

// CodePage returns the encoding of the code page name or alias.
// But without any of the custom, ASA ASCII or ISO-8859-11 encodings.
func CodePage(s string) (encoding.Encoding, error) <span class="cov8" title="1">{
        cp, err := convert.Encoder(s)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">switch cp </span>{
        case traditionalchinese.Big5:<span class="cov0" title="0">
                return nil, ErrBig5</span>
        case uni.UTF16(uni.BigEndian, uni.UseBOM),
                uni.UTF16(uni.BigEndian, uni.IgnoreBOM),
                uni.UTF16(uni.LittleEndian, uni.IgnoreBOM):<span class="cov0" title="0">
                return nil, ErrUTF16</span>
        case utf32.UTF32(utf32.BigEndian, utf32.UseBOM),
                utf32.UTF32(utf32.BigEndian, utf32.IgnoreBOM),
                utf32.UTF32(utf32.LittleEndian, utf32.IgnoreBOM):<span class="cov0" title="0">
                return nil, ErrUTF32</span>
        }
        <span class="cov8" title="1">return cp, nil</span>
}

// Swapper returns the Windows1252 charmap for use as the base template
// for the ASA ASCII encodings.
func swapper(name string) encoding.Encoding <span class="cov8" title="1">{
        switch strings.ToLower(name) </span>{
        case xud.Name11, xud.Numr11, xud.Alias11:<span class="cov0" title="0">
                return xud.XUserDefinedISO11</span>
        case xud.Name63, xud.Numr63:<span class="cov0" title="0">
                return charmap.Windows1252</span>
        case xud.Name65, xud.Numr65:<span class="cov0" title="0">
                return charmap.Windows1252</span>
        case xud.Name67, xud.Numr67, xud.Alias67:<span class="cov0" title="0">
                return charmap.Windows1252</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func reverter(name string) encoding.Encoding <span class="cov8" title="1">{
        switch strings.ToLower(name) </span>{
        case xud.Name11, xud.Numr11, xud.Alias11:<span class="cov0" title="0">
                return nil</span> // we don't want to revert to the custom charmap
        case xud.Name63, xud.Numr63:<span class="cov0" title="0">
                return xud.XUserDefined1963</span>
        case xud.Name65, xud.Numr65:<span class="cov0" title="0">
                return xud.XUserDefined1965</span>
        case xud.Name67, xud.Numr67, xud.Alias67:<span class="cov0" title="0">
                return xud.XUserDefined1967</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// SHY240 reports whether the code page has a SHY (soft hyphen) at code 240.
func SHY240(x encoding.Encoding) bool <span class="cov8" title="1">{
        switch x </span>{
        case charmap.CodePage850,
                charmap.CodePage852,
                charmap.CodePage855,
                charmap.CodePage858:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// SHY173 reports whether the code page has a SHY (soft hyphen) at code 173.
func SHY173(name string) bool <span class="cov8" title="1">{
        s := strings.ToLower(name)
        if strings.Contains(s, "windows 125") ||
                strings.Contains(s, "iso 8859-") ||
                strings.Contains(s, "iso-8859-") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Replacement returns a replacement character for the code page.
func Replacement(name string, code int) string <span class="cov8" title="1">{
        x, _ := CodePage(name)
        switch x </span>{
        case charmap.CodePage850,
                charmap.CodePage858,
                charmap.CodePage865,
                charmap.CodePage437:<span class="cov8" title="1">
                const shy = 152
                if code == shy </span><span class="cov8" title="1">{
                        return "\u00FF"
                }</span>
        }
        <span class="cov8" title="1">if SHY240(x) </span><span class="cov0" title="0">{
                const shy = 240
                if code == shy </span><span class="cov0" title="0">{
                        return "-"
                }</span>
                <span class="cov0" title="0">return ""</span>
        }
        <span class="cov8" title="1">if SHY173(name) </span><span class="cov0" title="0">{
                const shy = 173
                if code == shy </span><span class="cov0" title="0">{
                        return "-"
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// Character converts code or rune to an character mapped string.
func Character(cp encoding.Encoding, code int, r rune) string <span class="cov8" title="1">{
        if xud.Name(cp) != "" </span><span class="cov0" title="0">{
                if x := xud.Char(cp, code); x &gt; -1 </span><span class="cov0" title="0">{
                        return string(x)
                }</span>
                <span class="cov0" title="0">return string(r)</span>
        }
        // non-spacing mark characters
        <span class="cov8" title="1">if unicode.In(r, unicode.Mn) </span><span class="cov0" title="0">{
                // these require an additional monospace
                return " " + string(r)
        }</span>
        // format, other
        <span class="cov8" title="1">if unicode.In(r, unicode.Cf) </span><span class="cov8" title="1">{
                const zwnj, zwj, lrm, rlm = 8204, 8205, 8206, 8207
                switch r </span>{
                case zwnj, zwj, lrm, rlm:<span class="cov0" title="0">
                        return " "</span>
                }
        }
        // unicode latin-1 supplement
        <span class="cov8" title="1">if cp == uni.UTF8 || cp == uni.UTF8BOM </span><span class="cov8" title="1">{
                const pad, nbsp = 128, 160
                switch </span>{
                case code &gt;= pad &amp;&amp; code &lt; nbsp:<span class="cov8" title="1">
                        return " "</span>
                case code &gt;= nbsp:<span class="cov8" title="1">
                        return string(rune(code))</span>
                }
        }
        <span class="cov8" title="1">return string(r)</span>
}

// CharmapAlias humanizes encodings.
func CharmapAlias(cp encoding.Encoding) string <span class="cov8" title="1">{ //nolint:cyclop
        if c := charmapDOS(cp); c != "" </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov8" title="1">switch cp </span>{
        case charmap.CodePage1047:<span class="cov0" title="0">
                return " (C programming language)"</span>
        case charmap.CodePage1140:<span class="cov0" title="0">
                return " (US/Canada Latin 1 plus )"</span>
        case charmap.ISO8859_1, charmap.Windows1252:<span class="cov8" title="1">
                return " (Western European)"</span>
        case charmap.ISO8859_2, charmap.Windows1250:<span class="cov0" title="0">
                return " (Central European)"</span>
        case charmap.ISO8859_3:<span class="cov0" title="0">
                return " (South European)"</span>
        case charmap.ISO8859_4:<span class="cov0" title="0">
                return " (North European)"</span>
        case charmap.ISO8859_5, charmap.Windows1251:<span class="cov0" title="0">
                return " (Cyrillic)"</span>
        case charmap.ISO8859_6, charmap.Windows1256:<span class="cov0" title="0">
                return " (Arabic)"</span>
        case charmap.ISO8859_7, charmap.Windows1253:<span class="cov0" title="0">
                return " (Greek)"</span>
        case charmap.ISO8859_8, charmap.Windows1255:<span class="cov0" title="0">
                return " (Hebrew)"</span>
        case charmap.ISO8859_9, charmap.Windows1254:<span class="cov0" title="0">
                return " (Turkish)"</span>
        case charmap.ISO8859_10:<span class="cov0" title="0">
                return " (Nordic)"</span>
        case charmap.Windows874, xud.XUserDefinedISO11:<span class="cov8" title="1">
                return " (Thai)"</span>
        case charmap.ISO8859_13, charmap.Windows1257:<span class="cov0" title="0">
                return " (Baltic Rim)"</span>
        case charmap.ISO8859_14:<span class="cov0" title="0">
                return " (Celtic)"</span>
        case charmap.ISO8859_15:<span class="cov0" title="0">
                return " (Western European, 1999)"</span>
        case charmap.ISO8859_16:<span class="cov0" title="0">
                return " (South-Eastern European)"</span>
        }
        <span class="cov8" title="1">if c := charmapMisc(cp); c != "" </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// charmapDOS humanizes DOS encodings.
func charmapDOS(cp encoding.Encoding) string <span class="cov8" title="1">{
        switch cp </span>{
        case charmap.CodePage037:<span class="cov0" title="0">
                return " (US/Canada Latin 1)"</span>
        case charmap.CodePage437:<span class="cov8" title="1">
                return " (DOS, OEM-US)"</span>
        case charmap.CodePage850:<span class="cov0" title="0">
                return " (DOS, Latin 1)"</span>
        case charmap.CodePage852:<span class="cov0" title="0">
                return " (DOS, Latin 2)"</span>
        case charmap.CodePage855:<span class="cov0" title="0">
                return " (DOS, Cyrillic)"</span>
        case charmap.CodePage858:<span class="cov0" title="0">
                return " (DOS, Western Europe)"</span>
        case charmap.CodePage860:<span class="cov0" title="0">
                return " (DOS, Portuguese)"</span>
        case charmap.CodePage862:<span class="cov0" title="0">
                return " (DOS, Hebrew)"</span>
        case charmap.CodePage863:<span class="cov0" title="0">
                return " (DOS, French Canada)"</span>
        case charmap.CodePage865:<span class="cov0" title="0">
                return " (DOS, Nordic)"</span>
        case charmap.CodePage866:<span class="cov0" title="0">
                return " (DOS, Cyrillic Russian)"</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// charmapMisc humanizes miscellaneous encodings.
func charmapMisc(cp encoding.Encoding) string <span class="cov8" title="1">{
        switch cp </span>{
        case charmap.KOI8R:<span class="cov0" title="0">
                return " (Russian)"</span>
        case charmap.KOI8U:<span class="cov0" title="0">
                return " (Ukrainian)"</span>
        case charmap.Macintosh:<span class="cov0" title="0">
                return " (Mac OS Roman)"</span>
        case charmap.Windows1258:<span class="cov0" title="0">
                return " (Vietnamese)"</span>
        case japanese.ShiftJIS:<span class="cov8" title="1">
                return " (Japanese)"</span>
        case traditionalchinese.Big5:<span class="cov8" title="1">
                return " (Traditional Chinese)"</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// charmapStandard humanizes common encodings.
func charmapStandard(cp encoding.Encoding) string <span class="cov8" title="1">{
        switch cp </span>{
        case charmap.CodePage037, charmap.CodePage1047, charmap.CodePage1140:<span class="cov0" title="0">
                return " - EBCDIC"</span>
        case uni.UTF8, uni.UTF8BOM:<span class="cov0" title="0">
                return " - Unicode"</span>
        default:<span class="cov8" title="1">
                return " - Extended ASCII"</span>
        }
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Package term provides colors and text formatting for the terminal.
package term

import (
        "bufio"
        "errors"
        "fmt"
        "html/template"
        "io"
        "log"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "unicode/utf8"

        "github.com/gookit/color"
)

var ErrRune = errors.New("invalid encoded rune")

const (
        // HBar is a the Unicode horizontal bar character.
        HBar = "\u2500"
        none = "none"
        term = "terminal"
)

// Terminal color support.
type Terminal int

const (
        TermMono Terminal = iota // monochrome with no color
        Term16                   // ANSI standard 16 color
        Term88                   // XTerm with 88 colors
        Term256                  // XTerm with 256 colors
        Term16M                  // ANSI high-color with 16 million colors
)

// String returns the terminal as a named color value.
func (t Terminal) String() string <span class="cov8" title="1">{
        return [...]string{none, term, term, "terminal256", "terminal16m"}[t]
}</span>

// Border wraps the string around a single line border.
func Border(w io.Writer, s string) <span class="cov8" title="1">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">const split = 2
        maxLen, scanner := 0, bufio.NewScanner(strings.NewReader(s))
        scanner.Split(bufio.ScanLines)
        for scanner.Scan() </span><span class="cov8" title="1">{
                l := utf8.RuneCountInString(scanner.Text())
                if l &gt; maxLen </span><span class="cov8" title="1">{
                        maxLen = l
                }</span>
        }
        <span class="cov8" title="1">maxLen += split
        scanner = bufio.NewScanner(strings.NewReader(s))
        scanner.Split(bufio.ScanLines)
        fmt.Fprintln(w, ("" + strings.Repeat("", maxLen) + ""))
        for scanner.Scan() </span><span class="cov8" title="1">{
                l := utf8.RuneCountInString(scanner.Text())
                lp := ((maxLen - l) / split)
                rp := lp
                // if lp/rp are X.5 decimal values, add 1 right padd to account for the uneven split
                if float32((maxLen-l)/split) != float32(maxLen-l)/split </span><span class="cov0" title="0">{
                        rp++
                }</span>
                <span class="cov8" title="1">fmt.Fprintf(w, "%s%s%s\n", strings.Repeat(" ", lp), scanner.Text(), strings.Repeat(" ", rp))</span>
        }
        <span class="cov8" title="1">fmt.Fprintln(w, ""+strings.Repeat("", maxLen)+"")</span>
}

// Center align text to a the width of an area.
// If the width is less than the length of the string, the string is returned.
// There is no padding after the string.
func Center(width int, s string) string <span class="cov8" title="1">{
        const split, space = 2, "\u0020"
        if w := (width - len(s)) / split; w &gt; 0 </span><span class="cov8" title="1">{
                return strings.Repeat(space, w) + s
        }</span>
        <span class="cov8" title="1">return s</span>
}

// GetEnv gets and formats the value of the environment variable named in the key.
func GetEnv(key string) string <span class="cov0" title="0">{
        return strings.TrimSpace(strings.ToLower(os.Getenv(key)))
}</span>

// Head returns a colored and underlined string for use as a header.
// Provide a fixed width value for the underline border or set to zero.
// The header is colored with the fuzzy color.
func Head(w io.Writer, width int, s string) <span class="cov8" title="1">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">r := color.OpFuzzy.Sprint(strings.Repeat(HBar, width))
        h := color.Primary.Sprint(Center(width, s))
        fmt.Fprintln(w, r)
        fmt.Fprintln(w, h)</span>
}

// HR returns a horizontal ruler and a line break.
func HR(w io.Writer, width int) <span class="cov8" title="1">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(w, " %s\n", Secondary(strings.Repeat(HBar, width)))</span>
}

// Term determines the terminal type based on the COLORTERM and TERM environment variables.
//
// Possible reply values are: terminal, terminal16, terminal256, terminal16m.
//
// The value terminal is a monochrome terminal.
//
// The value terminal16 is a 4-bit, 16 color terminal.
//
// The value terminal256 is a 8-bit, 256 color terminal.
//
// The value terminal16m is a 24-bit, 16 million color terminal.
func Term(colorEnv, env string) string <span class="cov8" title="1">{
        // 9.11.2 The environment variable TERM
        // https://www.gnu.org/software/gettext/manual/html_node/The-TERM-variable.html
        // Terminal Colors
        // https://gist.github.com/XVilka/8346728

        // first, attempt to detect a COLORTERM variable
        switch colorEnv </span>{
        case "24bit", "truecolor":<span class="cov8" title="1">
                return Term16M.String()</span>
        }
        // then fallback to the -color suffix in TERM variable values
        <span class="cov8" title="1">s := strings.Split(env, "-")
        if len(s) &gt; 1 </span><span class="cov8" title="1">{
                switch s[len(s)-1] </span>{
                case "mono":<span class="cov8" title="1">
                        return TermMono.String()</span>
                case "color", "16color", "88color":<span class="cov8" title="1">
                        return Term16.String()</span>
                case "256color":<span class="cov8" title="1">
                        return Term256.String()</span>
                }
        }
        // otherwise do a direct match of the TERM variable value
        <span class="cov8" title="1">switch env </span>{
        case "linux":<span class="cov0" title="0">
                return TermMono.String()</span>
        case "konsole", "rxvt", "xterm", "vt100":<span class="cov8" title="1">
                return Term16.String()</span>
        }
        <span class="cov8" title="1">return Term256.String()</span>
}

// UnderlineChar uses ANSI to underline the first character of a string.
func UnderlineChar(s string) (string, error) <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if !utf8.ValidString(s) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("underlinechar %q: %w", s, ErrRune)
        }</span>
        <span class="cov8" title="1">if !color.Enable </span><span class="cov0" title="0">{
                return s, nil
        }</span>
        <span class="cov8" title="1">b := &amp;strings.Builder{}
        r, _ := utf8.DecodeRuneInString(s)
        t, err := template.New("underline").Parse("{{define \"TEXT\"}}\033[0m\033[4m{{.}}\033[0m{{end}}")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("underlinechar new template: %w", err)
        }</span>
        <span class="cov8" title="1">if err := t.ExecuteTemplate(b, "TEXT", string(r)); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("underlinechar execute template: %w", err)
        }</span>
        <span class="cov8" title="1">return b.String(), nil</span>
}

// UnderlineKeys uses ANSI to underline the first letter of each key.
func UnderlineKeys(keys ...string) string <span class="cov0" title="0">{
        if len(keys) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)
        for i, key := range keys </span><span class="cov0" title="0">{
                if utf8.RuneCountInString(key) &gt; 1 </span><span class="cov0" title="0">{
                        r, _ := utf8.DecodeRuneInString(key)
                        c, err := UnderlineChar(string(r))
                        if err != nil </span><span class="cov0" title="0">{
                                keys[i] = key
                        }</span>
                        <span class="cov0" title="0">keys[i] = fmt.Sprintf("%s%s", c, key[utf8.RuneLen(r):])
                        if filepath.Ext(key) != ".min" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">s := strings.Split(keys[i], ".")
                        if len(s) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">base := strings.Join(s[0:len(s)-1], ".")
                        m, err := UnderlineChar("m")
                        if err != nil </span><span class="cov0" title="0">{
                                // must use standard log package
                                log.Fatal("underline keys", keys, err)
                        }</span>
                        <span class="cov0" title="0">keys[i] = fmt.Sprintf("%s.%sin", base, m)
                        continue</span>
                }
                <span class="cov0" title="0">c, err := UnderlineChar(key)
                if err != nil </span><span class="cov0" title="0">{
                        keys[i] = key
                        continue</span>
                }
                <span class="cov0" title="0">keys[i] = c</span>
        }
        <span class="cov0" title="0">return strings.Join(keys, ", ")</span>
}

// Alert returns the string "Problem:" using the error color.
func Alert() string <span class="cov8" title="1">{
        return color.Error.Sprint("Problem:") + "\n"
}</span>

// Example returns the string using the debug color.
func Example(s string) string <span class="cov0" title="0">{
        return color.Debug.Sprint(s)
}</span>

// Inform returns "Information:" using the info color.
func Inform() string <span class="cov0" title="0">{
        return color.Info.Sprint("Information:") + "\n"
}</span>

// Bool returns a checkmark  when true or a cross  when false.
func Bool(b bool) string <span class="cov8" title="1">{
        const check, cross = "", ""
        if b </span><span class="cov8" title="1">{
                return color.Success.Sprint(check)
        }</span>
        <span class="cov8" title="1">return color.Warn.Sprint(cross)</span>
}

// Options writes the string and a sorted list of opts to the writer.
// If shorthand is true, the options are underlined.
// If flag is true, the string is prepended with "flag".
func Options(w io.Writer, s string, shorthand, flag bool, opts ...string) <span class="cov8" title="1">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">if len(opts) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">sort.Strings(opts)
        keys := strings.Join(opts, ", ")
        if shorthand </span><span class="cov0" title="0">{
                keys = UnderlineKeys(opts...)
        }</span>
        <span class="cov8" title="1">if flag </span><span class="cov0" title="0">{
                fmt.Fprintln(w, s)
                fmt.Fprintf(w, "flag options: %s", color.Info.Sprint(keys))
                return
        }</span>
        <span class="cov8" title="1">fmt.Fprintln(w, s+".")
        fmt.Fprintf(w, "  Options: %s", color.Info.Sprint(keys))</span>
}

// Comment returns a string in the comment color.
func Comment(s string) string <span class="cov8" title="1">{
        return color.Comment.Sprint(s)
}</span>

// Fuzzy returns a string in the fuzzy color.
func Fuzzy(s string) string <span class="cov0" title="0">{
        return color.OpFuzzy.Sprint(s)
}</span>

// Info returns a string in the info color.
func Info(s string) string <span class="cov0" title="0">{
        return color.Info.Sprint(s)
}</span>

// Secondary returns a string in the secondary color.
func Secondary(s string) string <span class="cov8" title="1">{
        return color.Secondary.Sprint(s)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">// Package xud provides X User Defined, character encodings.
// It does not encode or decode text, only provides information about the encodings.
//
// This includes the early American Standards Association (ASA) ASCII character encodings.
// There are three ASA encodings, X3.4-1963, X3.4-1965, X3.4-1967 and one missing ISO 8859-11 encoding.
// These encodings are not compatible with each other.
//
// But the X3.4-1967 character codes are compatible with the ANSI X3.4-1977 and ANSI X3.4-1986 encodings.
// Which are also compatible with many of the IBM Code Page and ISO 8859-X encodings, as-well as Unicode.
package xud

import (
        "errors"
        "fmt"
        "io"
        "strings"

        "golang.org/x/text/encoding"
        "golang.org/x/text/encoding/charmap"
)

// Named, numeric and alias values for the legacy ASA ASCII character encodings.
const (
        Name11  = "iso-8859-11" // name of ISO 8859-11
        Name63  = "ascii-63"    // name of ASA X3.4 1963
        Name65  = "ascii-65"    // name of ASA X3.4 1965
        Name67  = "ascii-67"    // name of ANSI X3.4 1967/77/86
        Numr11  = "11"          // numeric value for ISO 8859-11
        Numr63  = "1963"        // numeric value for ASA X3.4 1963
        Numr65  = "1965"        // numeric value for ASA X3.4 1965
        Numr67  = "1967"        // numeric value for ANSI X3.4 1967/77/86
        Alias11 = "iso885911"   // alias for ISO 8859-11
        Alias67 = "ansi"        // alias for ANSI X3.4 1967/77/86
)

var ErrName = errors.New("there is no encoding name")

// Encoding is an implementation of the Encoding interface that adds a formal name
// to a custom encoding.
type Encoding struct {
        encoding.Encoding // Encoding is the underlying encoding.

        Name string // Name is the formal name of the character encoding.
}

var (
        // XUserDefinedISO11 ISO-8859-11.
        XUserDefinedISO11 encoding.Encoding = &amp;xThaiISO11
        // XUserDefined1963 ASA X3.4 1963.
        XUserDefined1963 encoding.Encoding = &amp;x34_1963
        // XUserDefined1965 ASA X3.4 1965.
        XUserDefined1965 encoding.Encoding = &amp;x34_1965
        // XUserDefined1967 ANSI X3.4 1967/77/86.
        XUserDefined1967 encoding.Encoding = &amp;x34_1967

        xThaiISO11 = Encoding{
                Encoding: charmap.Windows874,
                Name:     "ISO-8859-11",
        }

        x34_1963 = Encoding{
                Encoding: charmap.Windows1252,
                Name:     "ASA X3.4 1963",
        }
        x34_1965 = Encoding{
                Encoding: charmap.Windows1252,
                Name:     "ASA X3.4 1965",
        }
        x34_1967 = Encoding{
                Encoding: charmap.Windows1252,
                Name:     "ANSI X3.4 1967/77/86",
        }
)

// String returns the formal name of the ASA encoding.
func (e Encoding) String() string <span class="cov8" title="1">{
        return e.Name
}</span>

// CodePage returns the encoding of the code page name or alias.
func CodePage(name string) encoding.Encoding <span class="cov0" title="0">{
        switch strings.ToLower(name) </span>{
        case Name11, Numr11, Alias11:<span class="cov0" title="0">
                return XUserDefinedISO11</span>
        case Name63, Numr63:<span class="cov0" title="0">
                return XUserDefined1963</span>
        case Name65, Numr65:<span class="cov0" title="0">
                return XUserDefined1965</span>
        case Name67, Numr67, Alias67:<span class="cov0" title="0">
                return XUserDefined1967</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// Code7bit reports whether the encoding is a 7-bit ASCII encoding.
// The 7-bit encodings are limited to 127 characters.
// The more common 8-bit encodings are limited to 256 characters.
func Code7bit(e encoding.Encoding) bool <span class="cov8" title="1">{
        switch e </span>{
        case XUserDefined1963, XUserDefined1965, XUserDefined1967:<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Name returns a named value for the legacy ASA ASCII character encodings.
func Name(e encoding.Encoding) string <span class="cov8" title="1">{
        switch e </span>{
        case XUserDefinedISO11:<span class="cov0" title="0">
                return Name11</span>
        case XUserDefined1963:<span class="cov8" title="1">
                return Name63</span>
        case XUserDefined1965:<span class="cov8" title="1">
                return Name65</span>
        case XUserDefined1967:<span class="cov8" title="1">
                return Name67</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// Numeric returns a numeric value for the legacy ASA ASCII character encodings.
func Numeric(e encoding.Encoding) string <span class="cov8" title="1">{
        switch e </span>{
        case XUserDefinedISO11:<span class="cov0" title="0">
                return Numr11</span>
        case XUserDefined1963:<span class="cov8" title="1">
                return Numr63</span>
        case XUserDefined1965:<span class="cov8" title="1">
                return Numr65</span>
        case XUserDefined1967:<span class="cov8" title="1">
                return Numr67</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// Alias returns an alias value for the legacy ASA ASCII character encodings.
func Alias(e encoding.Encoding) string <span class="cov8" title="1">{
        switch e </span>{
        case XUserDefinedISO11:<span class="cov0" title="0">
                return Alias11</span>
        case XUserDefined1967:<span class="cov8" title="1">
                return Alias67</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// Footnote returns a footnote value for the legacy ASA ASCII character encodings.
func Footnote(w io.Writer, e encoding.Encoding) <span class="cov8" title="1">{
        if w == nil </span><span class="cov0" title="0">{
                w = io.Discard
        }</span>
        <span class="cov8" title="1">switch e </span>{
        case XUserDefined1963:<span class="cov8" title="1">
                fmt.Fprintln(w)
                fmt.Fprintln(w, "* ASA X3.4 1963 has a number of historic control codes in"+
                        "\n  rows 0 and 1 that are not printable in Unicode.")</span>
        case XUserDefined1965:<span class="cov0" title="0">
                fmt.Fprintln(w)
                fmt.Fprintln(w, "* ASA X3.4 1965 cell 1-A is SUB, but it is not printable in Unicode.")</span>
        }
}

// Char returns a string for the 8-bit, character encoding decimal code.
// If the code is not defined in the encoding, then a space is returned.
// If the code matches an existing Windows-1252 character, then -1 is returned.
func Char(e encoding.Encoding, code int) rune <span class="cov8" title="1">{
        switch e </span>{
        case XUserDefinedISO11:<span class="cov0" title="0">
                return CharISO885911(code)</span>
        case XUserDefined1963:<span class="cov8" title="1">
                return CharX3463(code)</span>
        case XUserDefined1965:<span class="cov8" title="1">
                return CharX3465(code)</span>
        case XUserDefined1967:<span class="cov8" title="1">
                return CharX3467(code)</span>
        }
        <span class="cov0" title="0">return -1</span>
}

// CharISO885911 returns a rune for the ISO-8859-11 character code.
// If the code is not defined in the encoding, then a space is returned.
// If the code matches an existing Windows-1252 character, then -1 is returned.
func CharISO885911(code int) rune <span class="cov0" title="0">{
        const pad, nbsp = 128, 160
        if code &gt;= pad &amp;&amp; code &lt; nbsp </span><span class="cov0" title="0">{
                return ' '
        }</span>
        <span class="cov0" title="0">return -1</span>
}

// CharX3463 returns a rune for the legacy ASA X3.4 1963 character code.
// If the code is not defined in the encoding, then a space is returned.
// If the code matches an existing Windows-1252 character, then -1 is returned.
func CharX3463(code int) rune <span class="cov8" title="1">{
        const blank = ' '
        const us, end = 31, 128
        if code &gt;= end || code == 125 </span><span class="cov0" title="0">{
                return blank
        }</span>
        <span class="cov8" title="1">if x := mapX3493(code); x &gt; 0 </span><span class="cov8" title="1">{
                return x
        }</span>
        <span class="cov0" title="0">if code &lt;= us </span><span class="cov0" title="0">{
                return blank
        }</span>
        <span class="cov0" title="0">if code &gt;= 96 &amp;&amp; code &lt;= 123 </span><span class="cov0" title="0">{
                return blank
        }</span>
        <span class="cov0" title="0">return rune(code)</span>
}

func mapX3493(i int) rune <span class="cov8" title="1">{
        m := map[int]rune{
                0:   '',
                4:   '',
                7:   '',
                9:   '',
                10:  '',
                11:  '',
                12:  '',
                13:  '',
                14:  '',
                15:  '',
                17:  '',
                18:  '',
                19:  '',
                20:  '',
                94:  '',
                95:  '',
                124: '',
                126: '',
                127: '',
        }
        return m[i]
}</span>

// CharX3465 returns a string for the legacy ASA X3.4 1965 character code.
// If the code is not defined in the encoding, then a space is returned.
// If the code matches an existing Windows-1252 character, then -1 is returned.
func CharX3465(code int) rune <span class="cov8" title="1">{
        const sub, grave, tilde, at, not, bar, end = 26, 64, 92, 96, 124, 126, 128
        if code &gt;= end </span><span class="cov0" title="0">{
                return ' '
        }</span>
        <span class="cov8" title="1">switch code </span>{
        case sub:<span class="cov0" title="0">
                return ' '</span>
        case grave:<span class="cov0" title="0">
                return '`'</span>
        case tilde:<span class="cov8" title="1">
                return '~'</span>
        case at:<span class="cov0" title="0">
                return '@'</span>
        case not:<span class="cov0" title="0">
                return ''</span>
        case bar:<span class="cov0" title="0">
                return '|'</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// CharX3467 returns a string for the legacy ASA X3.4 1967 character code.
// If the code is not defined in the encoding, then a space is returned.
// If the code matches an existing Windows-1252 character, then -1 is returned.
func CharX3467(code int) rune <span class="cov8" title="1">{
        const end = 128
        if code &gt;= end </span><span class="cov8" title="1">{
                return ' '
        }</span>
        <span class="cov8" title="1">return -1</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
